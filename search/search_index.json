{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>lpnTPM is Open Source Software (OSS), and Open Source Hardware (OSHW) Trusted Platform Module (TPM, also known as ISO/IEC 11889) is an international standard for a secure cryptoprocessor, a dedicated microcontroller designed to secure hardware through integrated cryptographic keys.</p> <p>What makes lpnTPM different from generally available solutions is openness. Software and hardware of lpnTPM can, without limits, be audited, fixed, and customized by communities and businesses. Open design address the lack of trustworthiness of proprietary closed source TPM products, which currently dominate the whole market. lpnTPM in production mode protects software by secure boot technology, and only the lpnTPM owner will update it. TPM modules enable measured boot and support verified boot, Dynamic Root of Trust for Measurement, and other security features. Another benefit of lpnTPM would be physical design, which solves the lack of standardization around pinout and connector.</p> <p>The ultimate goal of lpnTPM is to provide a trustworthy platform for future open evolution of Trusted Platform Module software and its application to various computing devices, resulting in better adoption of platform security.</p> <p>This project was funded through the NGI Assure Fund, a fund established by NLnet with financial support from the European Commission's Next Generation Internet programme, under the aegis of DG Communications Networks, Content and Technology under grant agreement No 957073.</p>"},{"location":"Softcore-CPU/","title":"Analysis of the TPM project launch on SoftCore-CPU","text":"<p>An alternative to hardware Hard-CPU (Or SoC containing Hard-CPU) is SoftCore-CPU implemented from FPGA programmable circuit resources. This solution, like any other, has its advantages, but also disadvantages - we will try to describe them in this short document.</p>"},{"location":"Softcore-CPU/#advantages","title":"Advantages","text":"<p>The main advantage of using SoftCore-CPU is its flexibility. We are able to \"sew\" our CPU as needed, adding or omitting the appropriate blocks with HDL code during synthesis. For example, if we don't need floating point calculations we can omit FPU unit. For a further example if we need fast calculating checksums we can add extension with hardware calculating of checksums (implemented in FPGA fabric). By incurring programming costs, we can extend the set of peripheral systems of such SoftCore-CPU. Another advantage is the possibility of implementing SoftCore-CPU in a standard FPGA chip without Hard-CPU.</p>"},{"location":"Softcore-CPU/#disadvantages","title":"Disadvantages","text":"<p>One of the main disadvantages is the lower performance of SoftCore-CPUs than Hard-CPU. The SoftCore-CPU's main clock frequency is usually just a bit over 100 MHz. Also, the occupancy of both basic FPGA blocks, such as LUTs and Flip-Flops, or more advanced ones, such as BRAM memory blocks or DSP blocks, is large. Requirements for more complex SoftCore-CPUs can exceed 30K LUTs and several thousand FFs. Therefore, it is necessary to select a large FPGA chip to implement such a solution. The FPGA chip selected to implement SoftCore-CPU must also be relatively fast.</p> <p>There are also other limitations related to other aspects of the SoftCore-CPU design. Often in SoftCore-CPU external RAM memory drivers are not implemented (for example for DDR memory). There are also often limitations in some programming tools for such SoftCore-CPU, such as bootloader or C/C++ compiler.</p>"},{"location":"Softcore-CPU/#softcore-cpu-selection-criteria","title":"SoftCore-CPU selection criteria","text":"<p>The SoftCore-CPU selection criteria for the hardware design of the TPM module have been specified in previous documents - the most important of which are:</p> <ul> <li>the existing driver for the external (in relation to FPGA) RAM memory for the   CPU</li> <li>The lower limit of the CPU RAM is 256 KB</li> <li>32-bit high-performance CPU</li> <li>efficient system bus (preferably with 'burst' mode support)</li> <li>fast interrupt controller</li> <li>a big advantage would be a DMA controller with the possibility of transfers   from BRAM FPGA memory to CPU RAM</li> <li>flexible configuration options</li> <li>flexible <code>bootloader</code> with the ability to boot RTOS and/or OS Linux</li> <li>well-functioning toolchain - C compiler and loader</li> <li>JTAG debbugger with <code>openOCD</code> support</li> <li>complete and detailed documentation</li> <li>sample programs showing how to use various soft-cpu modules</li> <li>it would be an advantage if SoftCore-CPU could be fully synthesized in open   source FPGA synthesis tools</li> </ul>"},{"location":"Softcore-CPU/#neorv32","title":"NEORV32","text":"<p>At this stage of work, we chose SoftCore-CPU named NEORV32 compatible with 32-bit RISC-V ISA. It happened because this project meets most of the requirements set out in the paragraph above. One of the important factors was the existing C++ compiler and the ability to debug CPU programs with the JTAG debugger. The existence of the UART based <code>Bootloader</code> is also important. Also the documentation for this project seems to be complete. The biggest disadvantage of this particular SoftCore-CPU is the lack of an external DDR3 memory driver, which will have to be added to this processor. Problematic may also be that this Soft-CPU was written in VHDL language and most open source tools only support Verilog.</p> <p>This project is available at GitHub.</p>"},{"location":"Softcore-CPU/#launching-neorv32","title":"Launching NEORV32","text":"<p>To familiarize ourselves with the NEORV32 project, we decided to run it on the QMTECH FPGA board with the Xilinx Artix-7 chip</p> <p>On the website of the NEORV32 project, there were several configurations for specific FPGAs from several FPGA manufacturers (Xilinx, Intel, Gowin) NEORV32 Setups We chose a ready configuration for the Artix-7 FPGA (XC7A100T) because this is the FPGA chip on the <code>QMTECH</code> development kit NEORV32 Setups In order to create the project NEORV32 in Xilinx Vivado, it was necessary to clone the project repository (with sub-modules) and use a ready-made script in the TCL language:</p> <pre><code>git clone https://github.com/stnolting/neorv32-setups.git\ngit submodule init\ngit submodule update\n</code></pre> <p>Then you had to go to the subdirectory</p> <pre><code>cd /&lt;neorv32 dir&gt;/neorv32-setups/vivado/nexys-a7-test-setup\n</code></pre> <p>open Xilinx Vivado and in <code>TCL Console</code> issue command</p> <pre><code>source create_project.tcl\n</code></pre> <p>This TCL script created an entire Vivado project for an Artix-7 FPGA chip with SoftCore-CPU implementation NEORV32 ready for synthesis. Then we started in Vivado the synthesis, implementation and generation of the bitstream for the project. Here is a photo of the test circuit: </p> <p>Synthesis, implementation and generation of FPGA configuration file ended without errors (there were some warnings): </p> <p>Then, using the JTAG programmer/debugger (<code>Xilinx Cable</code>) we loaded the configuration file into the FPGA set.</p>"},{"location":"TPM_with_LPC_protocol/","title":"LPC driver - implementation","text":""},{"location":"TPM_with_LPC_protocol/#introduction","title":"Introduction","text":"<p>The main goal of this document is showing the current state of development of the LPC driver for use in the lpnTPM project.</p>"},{"location":"TPM_with_LPC_protocol/#motivation","title":"Motivation","text":"<p>Even though the SPI interface for the TPM module is more and more popular, the LPC (<code>Low Pin Count</code>) interface is still widely used as a way to connect TPM module to the mainboard. We have considered possible hardware platforms in the past in this document.</p> <p>While the SPI and I2C interfaces are available on each microcontroller out there, the LPC hardware block is nearly not available on the generally-available microcontrollers, which raises some challenge here.</p>"},{"location":"TPM_with_LPC_protocol/#lpc-implementation-via-gpio","title":"LPC implementation via GPIO","text":"<p>At first, we have attempted to implement the <code>LPC</code> interface on MCU via GPIO. The <code>LPC</code> requires 33MHz clock, which might be challenging for a typical MCU.</p> <p>Initially we have used <code>Nucleo L476</code> which is clocked at 80MHz. We have decided to use some other board for this test, instead. <code>ESP32-WROOM32</code> board has been chosen as the hardware platform here. This hardware has dual-core Tensilica LX6 with 240 MHz clock and 512 KB SRAM, which is quite a powerful MCU. Here is a picture of test circuit which was used during our experiments:</p> <p></p> <p>We have started our test with a very simple application in <code>Arduino IDE</code> for switching the output GPIO pin using an interrupt assigned to another GPIO (Input) pin. There was a 33 MHz clock signal attached to this pin. In the interrupt routine, the state of the output GPIO pin had been negated. Here is screen-shot from logic analyzer software:</p> <p></p> <p>The signal in channel 0 is a 33 MHz clock, and the signal in channel 2 is an output GPIO pin. The maximum frequency of switching GPIO pins we could reach on this hardware was close to 380 kHz. The main reason for such bad results has been substantial latency in interrupts handling.</p> <p>We have also considered some other versions  of STM32 family MCUs, but based on the documentation, reaching the desired frequency would be very challenging as well.</p>"},{"location":"TPM_with_LPC_protocol/#shift-towards-fpga","title":"Shift towards FPGA","text":"<p>Given that we would not be able to switch the GPIO pins fast enough in reaction to the 33MHz clock, we have concluded that the better way of implementing the <code>LPC</code> driver could be the use of a programmable device like an FPGA or CPLD.</p> <p>But we also need a CPU for implementation of the TPM module logic and substantial amount of RAM. If we would use both MCU and FPGA on a single board, it would cause a major increase in the board's size. Fortunately, in the last years some SoCs (System on Chips) has appeared, which combine these two (MCU and FPGA) into a single chip.</p>"},{"location":"TPM_with_LPC_protocol/#hardware-selection","title":"Hardware selection","text":""},{"location":"TPM_with_LPC_protocol/#requirements","title":"Requirements","text":"<p>The most serious issues in our previous attempts to implement the TPM module was shortage of the SRAM memory in the selected MCU. Based on that and our other previous attempts, we could outline the hardware requirements for a new chip:</p> <ul> <li>sufficient (&gt;256kB) amount of SRAM,</li> <li>existence of a programmable logic (FPGA), as well as a fast bus connecting   FPGA and MCU,</li> <li>efficient MCU with desired peripherals (such as SPI).</li> </ul> <p>Another very important requirement (not strictly hardware-related) is the possibility of using open-source software for the applications development for this hardware.</p>"},{"location":"TPM_with_LPC_protocol/#eos-s3-soc","title":"EOS S3 SoC","text":"<p>Our candidate for a new hardware platform for this project is <code>QuickLogic EOS\u2122 S3 MCU + eFPGA SoCs</code>. It combines ARM Cortex-M4 MCU with 512 KB of SRAM (max. clock frequency is 80 MHz) and FPGA. FPGA and MCU are connected by a fast <code>Wishbone Bus</code> and can handle interrupts from FPGA to MCU. The MCU has many peripherals like <code>SPI</code>, <code>I2C</code>, <code>UARTs</code>, <code>Timers</code>, and so on.</p> <p><code>Quicklogic EOS S3 MCU + eFPGA SoC</code> had been chosen for the hardware part of this project because it fulfills all requirements related to the amount of RAM and overall performance. More description on this hardware can be found here.</p> <p>We carried out all development on an open-hardware board called Sparkfun QuickLogic Thing Plus - EOS S3. This board is based on Quicklogic <code>EOS S3</code> SoC.</p> <p>Some more references on this SoC and board:</p> <ul> <li>QuickLogic EOS S3 Ultra Low Power multicore MCU datasheet</li> <li>QuickLogic Thing Plus (EOS S3) Hookup Guide</li> </ul>"},{"location":"TPM_with_LPC_protocol/#hardware-setup","title":"Hardware setup","text":"<p>Below is picture of circuit used for development of this project:</p> <p></p> <p>It consist of the following parts:</p> <ul> <li><code>Sparkfun QuickLogic Thing Plus - EOS S3</code> board</li> <li>breadboard</li> <li>power adapter</li> <li>J-Link JTAG programmer/debugger</li> <li>USB 2 UART converter</li> </ul> <p>Note that in this photo we have used the <code>SEGGER J-Link</code> JTAG debugger for programming and debugging, but one can use different JTAG debugger for this purpose (such as the Olimex ARM-USB-OCD-H paired with OpenOCD.</p>"},{"location":"TPM_with_LPC_protocol/#software-setup","title":"Software setup","text":"<p>All development - both FPGA Verilog RTL part and ARM Cortex-M4 MCU development had been carried out using <code>Quicklogic QORC SDK</code>. QORC SDK consists of the following parts:</p> <ul> <li>Symbiflow package for FPGA synthessis (Yosys) and <code>place and route</code> tool   for implementation and generation of bitstream for FPGA</li> <li>GCC-cross compiler for ARM Cortex</li> <li>FreeRTOS</li> <li>Zephyr-RTOS</li> </ul> <p><code>QORC SDK</code> is fully open-source project.</p> <p>Another useful tools used during development are:</p> <ul> <li>Icarus Verilog simulator</li> <li>GTKWave </li> </ul> <p>These can be used to perform simulation of the implemented FPGA code.</p>"},{"location":"TPM_with_LPC_protocol/#software-repositories","title":"Software repositories","text":"<p>Github repository with source code (Verilog RTL code) of <code>LPC peripheral</code> and all files needed to perform simulation are located in the lpntpm-lpc-verilog repository.</p> <p>There are several files in this repository:</p> <ul> <li><code>lpc_periph.v</code>- <code>LPC Peripheral</code> implementation in Verilog</li> <li><code>lpc_host.v</code> - <code>LPC Host</code> implementation in Verilog</li> <li><code>lpc_defines.v</code>- auxiliary file with definition of constants used in the     implementation</li> <li><code>lpc_periph_tb.v</code> - test-bench for the <code>LPC Peripheral</code> implementation</li> </ul> <p>Another source code repository is the lpntpm-eos-s3-examples. It contains applications (FPGA and ARM Cortex-M4 MCU) for the <code>EOS S3</code> SoC.</p> <p>Two applications are important here: * test communication application   - used for testing the internal communication between FPGA and MCU parts     using the <code>Wishbone</code> bus and interrutps, * LPC test application   - used for testing the <code>LPC peripheral</code> embedded into the FPGA part,   - application is reading LPC cycles, and displaying these cycles via UART in     the MCU part.</p>"},{"location":"TPM_with_LPC_protocol/#lpc-driver-implementation","title":"LPC driver implementation","text":"<p>Because in TPM part of a project we only need to handle the I/O or TPM cycles of LPC protocol, we have develop a minimal implementation of the <code>LPC Peripheral</code>. Before writing RTL code in Verilog, we have studied several open-source implementations of LPC protocol, such as this one.</p> <p>The main reference for implementation of the LPC driver was Intel company LPC interface Specification document.</p> <p>The implementation so far can handle following types of LPC cycles:</p> <ul> <li>I/O LPC cycles (1 byte)</li> <li>TPM LPC cycles (1 byte)</li> </ul> <p>Other cycles of LPC protocol (such as Memory, Firmware, DMA) are not supported.</p> <p>This implementation is based on a simple FSM (Finite State Machine) handling individual phases of the LPC protocol cycle. There is also code for handling I/O ports and internal signals states for every phase of the LPC cycle.</p>"},{"location":"TPM_with_LPC_protocol/#lpc-peripheral","title":"LPC Peripheral","text":""},{"location":"TPM_with_LPC_protocol/#io-ports","title":"I/O ports","text":"<p>Here is table with all I/O ports of the <code>LPC Peripheral</code> module:</p> Direction Type Bus Port name Description input wire clk_i LPC clock (33,3 MHz) from LPC Host input wire nrst_i Active-low reset signal input wire lframe_i Active-low frame signal inout wire [ 3:0] lad_bus Multiplexed Command, Address and Data Bus input wire addr_hit_i output reg [ 4:0] current_state_o Current peripheral state  (FSM) input wire [ 7:0] din_i Data sent when host requests a read output reg [ 7:0] lpc_data_in_o Data received by peripheral for writing output wire [ 3:0] lpc_data_out_o Data sent to host when a read is requested output wire [15:0] lpc_addr_o 16-bit LPC Peripheral Address output wire lpc_en_o Active-high status signal indicating the peripheral is ready for next operation. output wire io_rden_sm_o Active-high read status output wire io_wren_sm_o Active-high write status output reg [31:0] TDATA 32-bit register with LPC cycle: Address, Data(8-bit) and type of opertion output reg READY Active-high status signal indicating that new cycle data is on TDATA <p>As one can see in I/O ports of the <code>LPC Peripheral</code> module, there are four common signals of the <code>LPC</code> protocol (<code>LPC Host</code> is connected to `LPC Peripheral by these lines). These signals are:</p> <ul> <li>clk_i</li> <li>nrst_i</li> <li>lframe_i</li> <li>lad_bus  (this 4-bit bi-directional multiplexed bus)</li> </ul> <p>Other signals are used to control the module and display information, or for internal purposes.</p>"},{"location":"TPM_with_LPC_protocol/#details","title":"Details","text":"<ol> <li>In line 42 of <code>lpc_periph.v</code> source is declared port:</li> </ol> <pre><code>inout  wire [ 3:0] lad_bus\n</code></pre> <p>This is a bi-directional (and tri-state) 4-bit bus. This bus is multiplexed and in different time slots during handling of the LPC cycle this bus shows up various data (for example: 4-bit parts of LPC Address, LPC Data, etc.).</p> <p>In source file <code>lpc_defines.v</code> are definitions of FSM states constants:</p> <pre><code>//---- FSM states definitions --------------------------\n   `define LPC_START       4'b0000\n   `define LPC_STOP        4'b1111\n   `define LPC_FW_READ     4'b1101\n   `define LPC_FW_WRITE    4'b1110\n. . .\n</code></pre> <p>In lines from 133 to 203 of <code>lpc_periph.v</code> there is implementation of main FSM (Finite State Machine) supporting transitions between different phases of LPC protocol cycles:</p> <pre><code>always @(*) begin\nif (nrst_i == 1'b0) fsm_next_state &lt;= `LPC_ST_IDLE;\nif (lframe_i == 1'b0) fsm_next_state &lt;= `LPC_ST_IDLE;\ncase(current_state_o)\n`LPC_ST_IDLE:\nbegin\nif (nrst_i == 1'b0) fsm_next_state &lt;= `LPC_ST_IDLE;\nelse if ((lframe_i == 1'b0) &amp;&amp; (lad_bus == 4'h0)) fsm_next_state &lt;= `LPC_ST_START;\nend\n`LPC_ST_START:\nbegin\n. . .\n</code></pre> <p>In lines from 99 to 111 of <code>lpc_periph.v</code> there is always block in which is determined when new cycle was started and when LPC cycle data are ready these data are packed and copied to 32-bit <code>TDATA</code> bus:</p> <pre><code>if (wasLpc_enHigh) begin\ncycle_cnt = cycle_cnt + 1;\nif ((cycle_cnt &gt; 1) &amp;&amp; (cycle_cnt &lt; 3)) begin\ndinAbuf[31:28] &lt;= 4'b0000;\ndinAbuf[27:12] &lt;= lpc_addr_o_reg;\ndinAbuf[11:4] &lt;= lpc_data_in_o;\ndinAbuf[3:2] &lt;= 2'b00;\ndinAbuf[1:0] &lt;= cycle_type;\nif (dinAbuf==memoryLPC[0]) newValuedata = 1'b0;\nelse newValuedata = 1'b1;\nTDATA &lt;= dinAbuf;\nmemoryLPC[0] &lt;= dinAbuf;\nend\n</code></pre> <p>The format of the data on the <code>TDATA</code> bus is as follows:</p> <ul> <li>bits <code>[31:28]</code> - filled with four zeros,</li> <li>bits <code>[27:12]</code> - placed 16-bits <code>LPC Address</code>,</li> <li>bits <code>[11:4]</code> - 8-bit <code>LPC Data</code>,</li> <li>bits <code>[3:0]</code> - cycle type (direction),</li> <li><code>1</code> for write,</li> <li><code>0</code> for read.</li> </ul> <p>In this last <code>always</code> block is also worked out <code>READY</code> signal. When <code>READY</code> is High <code>(1'b1)</code>, it means that there is new cycle data on <code>TDATA</code> bus. In target application for the <code>EOS S3 SoC</code>, cycle data from <code>TDATA</code> bus are sent by the internal <code>Wishbone</code> to the MCU when this data is displayed on <code>MCU UART</code>.</p>"},{"location":"TPM_with_LPC_protocol/#test-bench","title":"Test bench","text":"<p>Test-bench for performing simulation of the <code>LPC Peripheral</code> module is available in the: lpc_periph_tb.v file.</p> <p>Following fragment dumps file with wave forms (<code>.vcd</code>):</p> <pre><code>initial\nbegin\n// Initialize\n$dumpfile(\"lpc_periph_tb.vcd\");\n$dumpvars(0,lpc_periph_tb);\n</code></pre> <p>Following fragment is a main test routine - a <code>for loop</code>, generating 128 I/O cycles (alternately write and read):</p> <pre><code>for (i = 0; i &lt;= 128; i = i + 1) begin\n// Perform write\n#40  LFRAME_in  = 0;\nIO_Read_Flag   = 0;\n. . .\n</code></pre> <p>The accomplishment of simulation before tests on hardware (FPGA board) is very important and we carried out this process in great detail. Manual on how to simulate the <code>LPC Peripheral</code> module can be found in this README.</p>"},{"location":"TPM_with_LPC_protocol/#results-analysis","title":"Results analysis","text":"<p> Let's first look at basic LPC protocol signals:</p> <ul> <li>clk_i is LPC clock 33,3 MHz</li> <li>LRESET is LPC reset - active low</li> <li>LFRAME - Low state marks new LPC cycle</li> <li>rd_flag - High state marks read cycle</li> <li>wr_flag - high state marks write cycle</li> <li>host_ready - tells that Host is ready to handle next cycle</li> <li>periph_en - tells that LPC Peripheral is ready for next cycle</li> </ul> <p>What is also very important:</p> <ul> <li>current_periph_state[4:0] - this is 4-bit value of current peripheral FSM state</li> <li>current_host_state[4:0] - this is 4-bit value of current host FSM state</li> </ul> <p>One can see that states on the LPC peripheral mimics the states from LPC Host and sequences of states for I/O read cycle and I/O write cycle are in accordance with states described in the LPC interface specification Conclusion: the basic LPC Protocol signals are correct in presented simulation.</p> <p></p> <p>On the second screen from <code>GTKWave</code> the time scale is a little different from the previous screen. Important signals here are:</p> <ul> <li>host_addr_i[15:0] - this is LPC address on LPC Host</li> <li>host_wr_i[7:0] - this is 8-bit LPC data on LPC Host</li> </ul> <p>One can see that these address and data with some delay appears on <code>LPC Peripheral</code> signals:</p> <ul> <li>periph_addr_o[15:0] - received from Host LPC address</li> <li>periph_wr_o[7:0] - received from Host LPC cycle data</li> </ul> <p>And finally, one can see that <code>LPC Address</code> and <code>LPC Data</code> appear with some delay on <code>TDATABou[31:0]</code> - on this 32-bit bus are written <code>LPC Address</code> and <code>LPC Data</code> as has been described above. <code>READYNET</code> signal indicates that there is new data on <code>TDATA</code> bus. These two last signals (<code>TDATA</code> and <code>READY</code>) are used for sending LPC cycle data from FPGA to the MCU part of the SoC application.</p> <p>Summing up: after watching the simulation of <code>LPC Peripheral</code> we have a solid foundation to say that the tested circuit is working correctly.</p>"},{"location":"TPM_with_LPC_protocol/#eos-s3-applications","title":"EOS S3 applications","text":""},{"location":"TPM_with_LPC_protocol/#fpga-mcu-communication","title":"FPGA &lt;--&gt; MCU communication","text":"<p>The goal of this application if to test the communication between FPGA and MCU by internal <code>Wishbone</code> (and using interrupts).</p> <p><code>Quicklogic EOS S3</code> is rather complex circuit what you can see studying it's Technical Reference Manual.</p> <p>After reading this documentation we were missing a few important details that were needed to implement SoC application which can send data from FPGA part to ARM MCU program using internal bus. Frankly speaking, we needed bi-directional communication between FPGA and MCU in SoC. It wasn't clear how to generate all needed clocks, reset signals, set up interrupts in the FPGA part, and how to declare signals controlling the behavior of the internal bus.</p> <p>Happily for us, one of employee of <code>Quicklogic Corporation</code> posted in his Github repository very valuable examples of applications for the <code>EOS S3</code> SoC.</p> <p>One of these examples has been using such communication between FPGA and MCU parts of SoC. Based on this, we wrote simpler application using comunication between FPGA and MCU using <code>Wishbone</code>, and interrupts from FPGA to MCU.</p> <p>In the AL4S3B_FPGA_Top.v: one can see that top module:</p> <pre><code>module AL4S3B_FPGA_Top (\n\n// io_pad(s) from constraint file\nio_pad\n);\n</code></pre> <p>hasn't declared clock and asynchronous reset. We found that needed clocks and other signals (for example resets, Wishbone bus signals, etc.) are injected into the top module by use of the <code>cell_macro</code> primitive. <code>cell_macro</code> is part of SoC hardware (Similiar to IP core). It gave us the explanation of things that weren't clear before studying this example application. Here is the <code>cell_macro</code> used for generating clocks and other important signals for SoC:</p> <pre><code>// Verilog model of QLAL4S3B\nqlal4s3b_cell_macro\nu_qlal4s3b_cell_macro\n(\n// AHB-To-FPGA Bridge\n.WBs_ADR                   ( WBs_ADR                        ), // output [16:0] | Address Bus                   to   FPGA\n.WBs_CYC                   ( WBs_CYC                        ), // output        | Cycle Chip Select             to   FPGA\n.WBs_BYTE_STB              ( WBs_BYTE_STB                   ), // output  [3:0] | Byte Select                   to   FPGA\n.WBs_WE                    ( WBs_WE                         ), // output        | Write Enable                  to   FPGA\n.WBs_RD                    ( WBs_RD                         ), // output        | Read  Enable                  to   FPGA\n.WBs_STB                   ( WBs_STB                        ), // output        | Strobe Signal                 to   FPGA\n.WBs_WR_DAT                ( WBs_WR_DAT                     ), // output [31:0] | Write Data Bus                to   FPGA\n.WB_CLK                    ( WB_CLK                         ), // input         | FPGA Clock                    from FPGA\n.WB_RST                    ( WB_RST                         ), // output        | FPGA Reset                    to   FPGA\n.WBs_RD_DAT                ( WBs_RD_DAT                     ), // input  [31:0] | Read Data Bus                 from FPGA\n.WBs_ACK                   ( WBs_ACK                        ), // input         | Transfer Cycle Acknowledge    from FPGA\n\n// SDMA Signals\n.SDMA_Req                  ( {3'b000, 1'b0}                 ), // input   [3:0]\n.SDMA_Sreq                 ( 4'b0000                        ), // input   [3:0]\n.SDMA_Done                 (                                ), // output  [3:0]\n.SDMA_Active               (                                ), // output  [3:0]\n\n// FB Interrupts\n.FB_msg_out                ( {1'b0, 1'b0, 1'b0, FPGA_INTR[0]}), // input   [3:0]\n.FB_Int_Clr                ( 8'h0                           ), // input   [7:0]\n.FB_Start                  (                                ), // output\n.FB_Busy                   ( 1'b0                           ), // input\n\n// FB Clocks\n.Sys_Clk0                  ( Sys_Clk0                       ), // output\n.Sys_Clk0_Rst              ( Sys_Clk0_Rst                   ), // output\n.Sys_Clk1                  ( Sys_Clk1                       ), // output\n.Sys_Clk1_Rst              ( Sys_Clk1_Rst                   ), // output\n\n// Packet FIFO\n.Sys_PKfb_Clk              (  1'b0                          ), // input\n.Sys_PKfb_Rst              (                                ), // output\n.FB_PKfbData               ( 32'h0                          ), // input  [31:0]\n.FB_PKfbPush               (  4'h0                          ), // input   [3:0]\n.FB_PKfbSOF                (  1'b0                          ), // input\n.FB_PKfbEOF                (  1'b0                          ), // input\n.FB_PKfbOverflow           (                                ), // output\n\n// Sensor Interface\n.Sensor_Int                (                                ), // output  [7:0]\n.TimeStamp                 (                                ), // output [23:0]\n\n// SPI Master APB Bus\n.Sys_Pclk                  (                                ), // output\n.Sys_Pclk_Rst              (                                ), // output      &lt;-- Fixed to add \"_Rst\"\n.Sys_PSel                  (  1'b0                          ), // input\n.SPIm_Paddr                ( 16'h0                          ), // input  [15:0]\n.SPIm_PEnable              (  1'b0                          ), // input\n.SPIm_PWrite               (  1'b0                          ), // input\n.SPIm_PWdata               ( 32'h0                          ), // input  [31:0]\n.SPIm_Prdata               (                                ), // output [31:0]\n.SPIm_PReady               (                                ), // output\n.SPIm_PSlvErr              (                                ), // output\n\n// Misc\n.Device_ID                 ( Device_ID                      ), // input  [15:0]\n\n// FBIO Signals\n.FBIO_In                   (                                ), // output [13:0] &lt;-- Do Not make any connections; Use Constraint manager in SpDE to sFBIO\n.FBIO_In_En                (                                ), // input  [13:0] &lt;-- Do Not make any connections; Use Constraint manager in SpDE to sFBIO\n.FBIO_Out                  (                                ), // input  [13:0] &lt;-- Do Not make any connections; Use Constraint manager in SpDE to sFBIO\n.FBIO_Out_En               (                                ), // input  [13:0] &lt;-- Do Not make any connections; Use Constraint manager in SpDE to sFBIO\n\n// ???\n.SFBIO                     (                                ), // inout  [13:0]\n.Device_ID_6S              ( 1'b0                           ), // input\n.Device_ID_4S              ( 1'b0                           ), // input\n.SPIm_PWdata_26S           ( 1'b0                           ), // input\n.SPIm_PWdata_24S           ( 1'b0                           ), // input\n.SPIm_PWdata_14S           ( 1'b0                           ), // input\n.SPIm_PWdata_11S           ( 1'b0                           ), // input\n.SPIm_PWdata_0S            ( 1'b0                           ), // input\n.SPIm_Paddr_8S             ( 1'b0                           ), // input\n.SPIm_Paddr_6S             ( 1'b0                           ), // input\n.FB_PKfbPush_1S            ( 1'b0                           ), // input\n.FB_PKfbData_31S           ( 1'b0                           ), // input\n.FB_PKfbData_21S           ( 1'b0                           ), // input\n.FB_PKfbData_19S           ( 1'b0                           ), // input\n.FB_PKfbData_9S            ( 1'b0                           ), // input\n.FB_PKfbData_6S            ( 1'b0                           ), // input\n.Sys_PKfb_ClkS             ( 1'b0                           ), // input\n.FB_BusyS                  ( 1'b0                           ), // input\n.WB_CLKS                   ( 1'b0                           )  // input\n\n);\n</code></pre> <p>As one can see there is much more than only clocks. There is one big disadvantage related to using the <code>cell_macro</code> construct. This <code>cell macro</code> is just a <code>black box</code> and we haven't any model of how it works. This fact makes it an impossible simulation of FPGA is part of the application for SoC <code>EOS S3</code>, so we can't determine this way if an application is working properly. We just check if communication between FPGA and ARM Cortex-M4 MCU using <code>Wishbone</code> bu to <code>AHB</code> bridge and interrupts using hardware.</p> <p>In the AL4S3B_FPGA_ONION_LPCCTRL.v we have declared three 32-bit registers:</p> <pre><code>reg     [31:0]  BREATHE_0_CONFIG   = 32'h00000010;\nreg     [31:0]  BREATHE_1_CONFIG   = 32'h00002000;\nreg     [31:0]  BREATHE_2_CONFIG   = 32'h03000000;\n</code></pre> <p>Then in the <code>always</code> block:</p> <pre><code>     //-----------------------------------------------\ncnt3 = cnt3 + 1;\nif ((cnt3 &gt;= 1024000) &amp;&amp; (cnt3 &lt; 1024900))\nbegin //period 1.25s\nif (cnt3==1024000)\nbegin\nBREATHE_0_CONFIG = BREATHE_0_CONFIG + 1;\nBREATHE_1_CONFIG = BREATHE_1_CONFIG + 1;\nBREATHE_2_CONFIG = BREATHE_2_CONFIG + 1;\nend\nTIMER_o = 4'b1111;  //activate interrupt for MCU part\nend\nelse if (cnt3 &gt;= 1024900)\nbegin\ncnt3 = 20'h00000;\nTIMER_o = 4'b0000;  //deactivate interrupt for MCU part\nend\nend\n</code></pre> <p>we periodically increment these registers, and set <code>TIMER_o = 4'b1111</code> signal, which is interrupt vector passed to MCU. When MCU gets this intterupt, it programatically reads these registers by internal <code>Wishbone</code> to <code>AHB</code> bridge. After short time, the interrupt in FPGA is deactivated:</p> <pre><code>TIMER_o = 4'b0000;\n</code></pre> <p>On the MCU side, there is a handler for message generated in the ISR. In RTOS task code we have such fragment:</p> <pre><code>      case TIMERCTRL0_ISR:\ndbg_str(\"\\nInterrupt occured ISR\\n\");\n\nuint32_t register0 = hal_fpga_onion_breath_getval_reg (22);\ndbg_str(\"\\n\\n\");\ndbg_str_hex32(\"Register0: \", register0);\n\nuint32_t register1 = hal_fpga_onion_breath_getval_reg (21);\n\ndbg_str(\"\\n\\n\");\ndbg_str_hex32(\"Register1: \", register1);\n\nuint32_t register2 = hal_fpga_onion_breath_getval_reg (18);\n\ndbg_str(\"\\n\\n\");\ndbg_str_hex32(\"Register2: \", register2);\n\nbreak;\n</code></pre> <p>When message is detected, the values of these three registers are read from FPGA and displayed by MCU UART.</p> <p>Documentation on building and testing this application can be found in it's README.</p> <p>After test application is built and loaded to hardware, we can see changing values via UART (incremented by one in cycle) of the three test register which are getting read from the FPGA:</p> <p></p>"},{"location":"TPM_with_LPC_protocol/#embedded-lpc-peripheral","title":"Embedded LPC Peripheral","text":"<p>In the final step of this part of the development, we have embeded <code>LPC Peripheral</code> developed previously into <code>EOS S3</code> SoC application.</p> <p>As mentioned before, we cannot simulate the FPGA part of the SoC application because of the use of the <code>cell_macro</code> construction. But the <code>LPC Peripheral</code> was simulated before, so it should not be a huge problem.</p> <p>This application along with short documentation can be found in the lpntpm-eos-s3-examples repoistory.</p> <p>What was changed in FPGA part of application:</p> <ol> <li> <p>In top module <code>AL4S3B_FPGA_Top</code> were additional ports of LPC protocol added:</p> <pre><code>module AL4S3B_FPGA_Top (\n// LPC Slave Interface\nlpc_lclk_top         , // LPC clock 33 MHz     (external from LPC Host)\nlpc_lreset_n_top     , // Reset - Active Low   (external from LPC Host)\nlpc_lframe_n_top      , // Frame - Active Low   (external from LPC Host)\nlpc_lad_in_top       , // Bi-directional 4-bit LAD bus (tri-state) (external from LPC Host)\n\n// io_pad(s) from constraint file\nio_pad,\n\n//Wisbone bys clock 80 MHz\nclk80Mhz\n);\n</code></pre> <pre><code>// io_pad(s)\ninout   wire    [15:0]   io_pad ; //Decreased from [31:0]\n\n// LPC Slave Interface\ninput  wire        lpc_lclk_top         ; // LPC clock 33 MHz\ninput  wire        lpc_lreset_n_top     ; // Reset - Active Low\ninput  wire        lpc_lframe_n_top     ; // Frame - Active Low\ninout  wire [ 3:0] lpc_lad_in_top       ; // Bi-directional 4-bit LAD bus (tri-state)\n\n//Wisbone clock\noutput wire clk80Mhz;               //Clock 80 MHz\n</code></pre> </li> <li> <p>In module <code>AL4S3B_FPGA_IP</code>, also ports of the <code>LPC protocol</code> had been added:</p> <pre><code>module AL4S3B_FPGA_IP (\n\n// CLOCK/RESET\nCLK_IP_i,\nRST_IP_i,\n\n// AHB-To_FPGA Bridge I/F\nWBs_ADR,\nWBs_CYC,\nWBs_BYTE_STB,\nWBs_WE,\nWBs_RD,\nWBs_STB,\nWBs_WR_DAT,\nWB_CLK,\nWB_RST,\nWBs_RD_DAT,\nWBs_ACK,\n\n// io_pad\nio_pad,\n\n// FPGA Interrupts\nFPGA_INTR,\n\n// LPC Slave Interface\nlpc_lclk,     // LPC clock 33 MHz\nlpc_lreset_n, // Reset - Active Low\nlpc_lframe_n, // LPC Frame - Active Low\nlpc_lad_in    // Bi-directional 4-bit LAD bus (tri-state)\n\n);\n</code></pre> </li> <li> <p>During instantation of the <code>AL4S3B_FPGA_ONION_LPCCTRL</code> module (in which    <code>LPC Peripheral</code> is embbeded) - these ports also had been added:</p> <pre><code>AL4S3B_FPGA_ONION_LPCCTRL\nu_AL4S3B_FPGA_ONION_LPCCTRL\n(\n// AHB-To_FPGA Bridge I/F\n.WBs_ADR_i          ( WBs_ADR                           ),\n.WBs_CYC_i          ( WBs_CYC_ONION_LPCCTRL             ),\n.WBs_BYTE_STB_i     ( WBs_BYTE_STB                      ),\n.WBs_WE_i           ( WBs_WE                            ),\n.WBs_STB_i          ( WBs_STB                           ),\n.WBs_DAT_i          ( WBs_WR_DAT                        ),\n.WBs_CLK_i          ( WB_CLK                            ), //80 MHz\n.WBs_RST_i          ( WB_RST                            ),\n.WBs_DAT_o          ( WBs_DAT_o_ONION_LPCCTRL           ),\n.WBs_ACK_o          ( WBs_ACK_ONION_LPCCTRL             ),\n\n//System clk\n.Sys_clk            ( CLK_IP_i                          ), //33 MHz\n\n//System reset\n.Sys_reset          ( RST_IP_i                          ),\n\n// BREATHE signals\n.BREATHE_o          ( FPGA_IP_LPC_o[31:0]               ),\n\n// TIMER output interrupts\n.TIMER_o            ( FPGA_INTR                         ),\n\n// LPC Slave Interface\n.lpc_lclk           ( lpc_lclk                          ),   // LPC Frame input (active high)\n.lpc_lreset_n       ( lpc_lreset_n                      ),      // LPC AD Output Enable\n.lpc_lframe_n       ( lpc_lframe_n                      ),       // LPC AD Input Bus\n.lpc_lad_in         ( lpc_lad_in                        ),       // LPC AD Output Bus\n);\n</code></pre> </li> <li> <p>In module <code>AL4S3B_FPGA_ONION_LPCCTRL</code> I/O ports look like:</p> <pre><code>module AL4S3B_FPGA_ONION_LPCCTRL (\n\n// AHB-To_FPGA Bridge I/F\nWBs_ADR_i,\nWBs_CYC_i,\nWBs_BYTE_STB_i,\nWBs_WE_i,\nWBs_STB_i,\nWBs_DAT_i,\nWBs_CLK_i,  //80 MHz\nWBs_RST_i,\nWBs_DAT_o,\nWBs_ACK_o,\n\n// System clk 33 MHz\nSys_clk,\n\n//System reset\nSys_reset,\n\n// BREATHE signals\nBREATHE_o,\n\n// TIMER signals\nTIMER_o,\n\n// LPC Slave Interface\nlpc_lclk,     // LPC clock 33 MHz\nlpc_lreset_n, // Reset - Active Low\nlpc_lframe_n, // LPC Frame - Active Low\nlpc_lad_in    // Bi-directional 4-bit LAD bus (tri-state)\n);\n</code></pre> </li> <li> <p>In lines from 289 there is instantation of developed earlier \"LPC_Peri\" module:</p> <pre><code>//***************************\n// LPC Peripheral instantiation\n//***************************\nlpc_periph lpc_periph_inst(\n// LPC Interface\n.clk_i(lpc_lclk),\n.nrst_i(lpc_lreset_n),\n.lframe_i(lpc_lframe_n),\n.lad_bus(lpc_lad_in),\n.addr_hit_i(i_addr_hit_sig),\n.current_state_o(o_current_peri_state_sig),\n.din_i(i_din_sig),\n.lpc_data_in_o(o_lpc_data_in_sig),\n.lpc_data_out_o(o_lpc_data_out_sig),\n.lpc_addr_o(o_lpc_addr_sig),\n.lpc_en_o(o_lpc_en_sig),\n.io_wren_sm_o(o_io_wren_sm_sig),\n.io_rden_sm_o(o_io_wren_sm_sig),\n//----------------------------------\n.TDATA(TDATA_sig),\n.READY(READY_sig)\n);\n</code></pre> </li> </ol> <p>Caution: currently in module <code>AL4S3B_FPGA_ONION_LPCCTRL</code> we have two clock domains:</p> <ul> <li>one: with <code>WBs_CLK_i</code> - it is 80 MHz internal SoC Wishbone Bus clock</li> <li>second: <code>lpc_lclk</code> - it is external 33 MHz LPC clock (from LPC Host)</li> </ul> <p>Using multiple clock domains requires taking special steps in module implementation. For this reason, in module code (lines from 214 to 230) is generated signal clock enable for the LPC clock (33MHz):</p> <pre><code>/generating clock_33Mhz_enable signal\nalways @(posedge WBs_CLK_i)\nbegin\n//if (WBs_CLK_i)\n//begin\nif (counter == divisor)\nbegin\ncounter &lt;= 4'b0000;\nclock_33Mhz_enable &lt;= 1'b1;\nend\nelse\nbegin\nclock_33Mhz_enable &lt;= 1'b0;\ncounter &lt;= counter + 1'b1;\nend\n//end\nend\n</code></pre> <p>Here is <code>always</code> block for generating interrupt signal from FPGA 2 MCU(this interrupt cause that MCU reads register with LPC cycle data from FPGA):</p> <pre><code>// Logic for determine cycle type and send cycle data\nalways @( posedge WBs_CLK_i)\nbegin\nif (clock_33Mhz_enable)\nbegin\nif (READY_sig)\nbegin\nBREATHE_0_CONFIG_TMP = TDATA_sig; //all cycle data sent in one 32-bit register\nTIMER_o = 4'b1111;  //activate interrupt for MCU part\nend\nelse\nbegin\nTIMER_o = 4'b0000;  //deactivate interrupt for MCU part\nend\nend\nelse TIMER_o = 4'b0000;\nend\n</code></pre> <p>Then, in C source file <code>mininimal_task.c</code> is code which handles interrupt from FPGA and reads register from FPGA and decodes LPC Address, LPC Data, cycle type and prints these data on MCU UART. BTW: in source file: <code>fpga/src/hal_fpga_onion_timerctrl.c</code> is located code related to interrupts handling.</p> <p>As we mentioned earlier, we weren't able to simulate this code, because of using <code>cell_macro</code> construct.</p>"},{"location":"TPM_with_LPC_protocol/#further-plans","title":"Further plans","text":"<p>The current development of this project is starting point for development of full <code>TPM</code> hardware module with <code>LPC</code> protocol support.</p> <p>In next steps we plan to:</p> <ol> <li>Test working LPC protocol with <code>EOS S3</code> application on the Thing Plus board.    We have implemented <code>LPC Host</code> Verilog module, which is needed for the test    of <code>LPC Peripheral</code> on hardware. We are going to run <code>LPC Host</code> on second    FPGA board connected by wires to the <code>Thing Plus</code> board and test correctness    of operation of the LPC peripheral not only in simulation, but on real    hardware as well. We also planning to write <code>Test Generator</code> for <code>LPC Host</code>    as a Verilog module - which will be able to generate test signals. Moreover,    we want to test this <code>LPC Peripheral</code> module not only with test <code>LPC Host</code>,    but also with real mainboard.</li> <li>After determining that LPC cycles are properly detected and send to MCU in    SoC application, we are going to extend it to send back response by LPC    protocol lines in FPGA. We will define TPM registers in MCU and TPM cycles    of LPC protocol should be able to write and read from these registers    using LPC protocol.</li> <li>Next step is to develop full TPM module based on the    Microsoft TPM module reference 2.0reference Microsoft TPM    module source code, which would work with this TPM driver.</li> </ol>"},{"location":"building/","title":"Building, flashing, and debugging","text":""},{"location":"building/#build","title":"Build","text":"<p>Here you can find our fork of Official TPM 2.0 Reference Implementation (by Microsoft).</p> <p>The project is developed using STM32CubeIDE so the building process is straightforward.</p> <p>Just clone it with git...</p> <pre><code>git clone --recurse-submodules git@github.com:lpn-plant/ms-tpm-20-ref.git\ncd ms-tpm-20-ref\ngit checkout cmd_parsing\ngit submodule update\n</code></pre> <p>... and import it using <code>Import -&gt; Existing Project into Workspace</code> in <code>IDE Project Explorer</code>.</p> <p>Select <code>Nucleo-L476RG</code> project from <code>ms-tpm-20-ref/Samples/Nucleo-TPM/L476RG</code> directory.</p>"},{"location":"building/#flash-and-debug","title":"Flash and Debug","text":"<p>To flash/debug the application click on the green bug icon on the top toolbar and select <code>Nucleo-L476RG Debug</code>.</p> <p></p> <p>If you cannot see it, select <code>Debug Configuration...</code> and it should be listed under <code>STM32 Cortex-M C/C++ Application</code> menu selection.</p> <p>Some extra tweaks were necessary to enable SWV ITM traces, other than that we are using the default STLink debug configuration.</p> <p></p> <p>IDE debug configuration file is included in project root dir and should be automatically available <code>Nucleo-L476RG Debug.launch</code>.</p>"},{"location":"further_project_development/","title":"Further TPM Project development investigation","text":"<p>If we are going to plan further project development, we have to solve issues that appears in current work with project. The main issues are: + Lack of RAM memory in CPU + Rather low frequency of MCU clock</p> <p>In order to overcome that issues we have to choose more powerful microcontroller. Planned further implementation of LPC protocol on MCU require higher clock frequency (above 100 Mhz). In current project static code analysis shows RAM memory occupancy above 96 percent.</p>"},{"location":"further_project_development/#current-project-code-analysis-in-terms-of-hardware-dependence","title":"Current project code analysis in terms of hardware dependence","text":"<p>We start project code analysis (Nucleo-L476RG) with basic files defining hardware components. Catalog \"Src\" - basic files:</p> <ol> <li>system_stm32l4xx.c</li> </ol> <p>In this file are defined major hardware parameters: clock frequency, SRAM, FPU. It can be generated by \"STM32CubeMX\" software for different MCU model from STM32 family. 2. stm32l4xx_hal_msp.c</p> <p>In this file is located code for initialisation of hardware modules and peripherals. It can be generated by \"STM32CubeMX\" software for different MCU model from STM32 family</p> <ol> <li>stm32l4xx_it.c</li> </ol> <p>This file includes hardware components and peripherals interrupt handlers routines. In this file is located code for initialisation of hardware modules and peripherals. It can be generated by \"STM32CubeMX\" software for different MCU model from STM32 family.</p> <ol> <li>main.c</li> </ol> <p>This file is application starter and includes also hardware initialisation procedures. Here are hardware initialisation functions:</p> <pre><code>void SystemClock_Config(void);\nstatic void MX_GPIO_Init(void);\nstatic void MX_RNG_Init(void);\nstatic void MX_RTC_Init(void);\nstatic void MX_USART2_UART_Init(void);\n</code></pre> <p>These functions can be generated by \"STM32CubeMX\" software for different MCU model from STM32 family.</p> <p>Remaining code files in this catalog are related to USB CDC device and could be removed after going on SPI or LPC protocol.</p> <p>Catalog \"startup\" is generated automaticaly during creating new project by \"STM32CubeMX\".</p> <p>Catalog \"Inc\" contains header files for major code files in project:</p> <ul> <li>stm32l4xx_it.h</li> <li>stm32l4xx_hal_conf.h</li> <li>main.h</li> </ul> <p>These files can be generated by \"STM32CubeMX\" software for different MCU model from STM32 family. There also are located header files for USB device, which could be removed removed after going on SPI or LPC protocol. In sub-catalogs</p> <ul> <li>Platform</li> <li>TPMCmd</li> <li>TPMDevice</li> </ul> <p>there are located header files related to reference implementation of TPM (Microsoft) - these files are not dependent of hardware.</p> <p>In \"Drivers\" catalog are located basic hardware layer drivers:</p> <ul> <li>CMSIS</li> <li>STM32L4xx_HAL_Driver</li> </ul> <p>These catalogs are automaticaly copied to project during creating of project. In the case of choosing of different MCU (not STM32 family) the CMSIS drivers also would be copied to project, but HAL library can be quite different.</p> <p>\u201cMiddlewares\u201d catalog includes major implementation of TPM (Microsoft company) and also implemantation of USB device. USB library code is located in:</p> <ul> <li>ST \u2192 STM32_USB_Device_Library</li> </ul> <p>TPM implementation is located in sub-catalogs:</p> <ul> <li>Platform</li> <li>TPMCmd</li> <li>TPMDevice</li> <li>wolfcrypt</li> </ul> <p>TPM implementation is independent from hardware.</p> <p>\"Includes\" catalod includes headers related to CMSIS library, HAL library, USB device and TPM. This code is related of hardware and might be most difficult to write for different MCU.</p>"},{"location":"further_project_development/#target-hardware-platform-for-tpm-arm-project","title":"Target hardware platform for TPM (ARM) project","text":"<p>The major difficulty for choosing new hardware platform (MCU) is current unavailability of semiconductors, so the major criterion is availability of particular MCU. New MCU have to let overcome issues described in the beginning of this document. In this purpose we made such assumptiuons for new MCU:</p> <ul> <li>MCU : ARM-Cortex-M4</li> <li>clock frequency from 168 Mhz to 200 Mhz</li> <li>LQFP64 case</li> <li>SRAM amount from 192 KB to 256 KB</li> </ul> <p>We choose device with ARM Cortex-M4 from \"GigaDevice\" company. Here is link to search engine on \"Gigadevice\" WWW page:</p> <p>High performance GD32 ARM Cirtex-M4 Microcontrollers</p> <p>The best candidate for new MCU seems this particular device:</p> <p>GD32F425RGT6</p> <p>The \"GigaDevice\" company also provides basic firmware: CMSIS library and few tools (for example programer, profiler). The reference IDE/Compiler for these GD32 MCU is \"Keil uVision\" (\"Segger Studio for ARM\" is also on list). There is also hardware programmer/debugger (JTAG) available.</p> <p>There is one difficulty with this GD32F4xx MCU family, there is not available \"HAL\" library for these devices. \"Gigadevice\" company id providing instead \"HAL\" libraries \"Standard Peripheral\" libray. \"Standard Peripheral\" libray was higher-level hardware abstraction library, before ST company write newer \"HAL\" library. \"Standard Peripheral\" library is from several years deprecated and what worse it's API is different from \"HAL\" API. This fact has impact on time estitmate for re-writing code for new MCU - all hardware dependent code have to be re-writing. So time estimates will be higher.</p>"},{"location":"hardware_interfaces/","title":"Target TPM hardware interfaces","text":"<p>As we are designing a universal TPM device, we are targeting multiple communication interfaces to talk to TPM. Our requirements are to use the most popular ones (LPC and SPI).</p> <p>The first interface, that we are looking to implement is SPI. That's mostly because we think it is the easiest way to start.</p> <p>We are planning to use lpnTPM with an embedded platform (such as Raspberry Pi) for test purposes. Some steps were made to archive it, but we are still in the development stage. Our goal is to be able to use <code>tpm2-tools</code> and emulate the behavior of already available TPM.</p>"},{"location":"hardware_interfaces/#required-spi-bus-speed","title":"Required SPI bus speed","text":"<p>As one of our requirements is to communicate with motherboards using SPI, we should also implement such communication.</p> <p>TCG PC Client Platform TPM Profile Specification for TPM 2.0 document greatly explains the actual requirements of SPI interface. On page <code>127</code> in the <code>7.4.1 Clocking</code> section, we can find the following must-have conditions for SPI bus speed.</p> <pre><code>1. The TPM SHALL support an SPI clock frequency range of 10 - 24MHz.\n2. The TPM MAY support running at lower frequencies.\n3. The TPM SHOULD support higher frequencies\n</code></pre> <p>Let's focus on STM32L476 and its integrated SPI peripheral. As mentioned on page <code>1450</code> of the STM32 RM0351 Reference manual STM32L4 limits SPI speed up to <code>APB2/2</code>, thus our maximum speed of the SPI interface is 40MHz.</p> <pre><code>42.2 SPI main features:\n  - Slave mode frequency up to fPCLK/2\n</code></pre> <p>Taking into account the TPM requirements we should be good to initiate communication.</p>"},{"location":"hardware_interfaces/#low-pin-count-interface","title":"Low pin count interface","text":"<p>LPC (Low Pin Count) interface is not available in popular microcontrollers.</p> <p>We have some ideas for software implementations of such. First of all, we would like to use some other hardware interfaces, to be able to emulate this interface and initialize correct communication.</p> <p>We found some interesting software that somehow could help us to start thinking of software-based LPC bus emulation: State machine IO driver for the Low-Pin Count bus slave.</p>"},{"location":"hardware_interfaces/#stm32-available-interfaces","title":"STM32 available interfaces","text":"<p>We will look towards <code>FSMC</code>, <code>SPI</code>, and <code>4-bit SDcard interface</code>. There is a chance, that by preparing special data packets we can simulate the behavior of the LPC interface using a more popular one.</p> <p>In our opinion bit-banging of such a fast interface (33MHz) will not be reasonable and will require us to choose a faster processor, as STM32L4 runs at a maximum 80MHz.</p> <p>We have found an example of Low-Pin Count bus slave state machine IO driver so it can be a great starting point for our development of software emulation of the LPC bus.</p> <p>The actual throughput of LPC bus is <code>2.47MB</code> - Table 18: Peripheral Initiated Memory Read Cycle so in case of bit-banging of the LPC interface we have to choose a microcontroller like STM32G4 Series with the maximum CPU clock speed of 170 MHz.</p>"},{"location":"hardware_interfaces/#using-spilpc-converters","title":"Using SPI/LPC converters","text":"<p>From what we found the one and only chip converter that is out there, to convert SPI to LPC is Microchip ECE1200</p> <p>It uses Enhanced <code>Serial Peripheral Interface (eSPI)</code>, which is a slightly modified version of the SPI interface.</p> <p>This outcome and FPGA one, listed below would reduce the need for main uC computing power.</p>"},{"location":"hardware_interfaces/#custom-made-fpga-converter","title":"Custom made FPGA converter","text":"<p>Lattice software stack offers LPC implementation for FPGA's and if we want to implement it that way, it would be a clear and elegant solution to create some kind of SPI&gt;LPC converter.</p> <p>Lattice XO2 series, avaliable in WLCSP25/WLCSP36 package (2,5mm x 2,5mm) would be sufficient.</p>"},{"location":"how_to/","title":"How to","text":"<p>lpnTPM is developed around Official TPM 2.0 Reference Implementation (by Microsoft).</p> <p>The project consists of a cross-platform simulator and samples both for Cortex M and Cortex A.</p> <p>The original port was developed on STM32L4A6RG and STM32L476RG microcontrollers using Atollic Studio. For future compatibility, we converted project files to STM32CubeIDE, which is a successor of Atollic software. The project doesn't provide any other build systems but we are definitely looking forward to use one.</p> <p>During the early development stage, we are using Nucleo L476RG board with USB cable connected to STM32 IO.</p> <p>Due to the limited amount of SRAM memory of such uC soon we will probably switch to a different one. We are currently looking at L4/F4 series in LQFP64 package. Probably for convenience, we will use some ready-made dev board as Nucleo L452RE with 160 KB of SRAM.</p> <p>At the current stage of development, we are using Nucleo USB CDC port to communicate to TPM core. We are targetting different interfaces - SPI, I2C, LPC is a must.</p> <p>STlink integrated serial port, as well as ITM traces, are used for debugging purposes.</p>"},{"location":"instrumentation/","title":"TPM driver instrumentation","text":"<p>For development purposes, a set of scripts was created that allows for the instrumentation of a specific module, allowing for tracing the execution of module functions.</p> <p>This could be especially useful in the process of development of different protocol backends in our <code>lpntpn</code> like LPC or I2C.</p> <p>For now, scripts are located inside our fork of ms-tpm-20-ref repository. Look for <code>Samples/Nucleo-TPM/scripts/kfunc_tracer</code> directory on the dev branch.</p> <p>We use the integrated functionality that gcc provides '-finstrument-function' for function instrumentation. This step allows us to register exact function call addresses and log them to dmesg.</p> <p>Next, we match the function addresses against kernel processes address space that's located in <code>/proc/modules</code> to identify loaded module, that fn call belongs to. By subtracting function address with start memory location of loaded module, we obtain the real offset of a function call, that could be easily matched with an exact function name.</p> <p>The last step is to extract functions memory offsets located in non-striped kernel modules. For this purpose we are using a simple readelf call: <code>readelf -s MODULE_NAME.ko | grep FUNC</code>.</p> <p>This process requires kernel recompilation, execution of module startup and parsing of resulting trace files.</p>"},{"location":"instrumentation/#prepare-raspberry-pi","title":"Prepare Raspberry Pi","text":"<p>We are using Raspberry Pi 3, but with minor modifications, this process could be used on different targets.</p> <p>Flash SD card with raspbian lite os.</p> <p>At the moment of writing image <code>2021-05-07-raspios-buster-armhf-lite.img</code> was used.</p> <p>Enable ssh.</p> <p>Execute on raspberry pi with connected keyboard and display</p> <pre><code># upgrade\nsudo apt update\nsudo apt upgrade\n\n# change default password\npasswd\n\n# enable ssh\nsudo systemctl enable ssh\nsudo systemctl start ssh\n</code></pre> <p>Check ssh connection.</p> <p>Environmental variable <code>RASPI_IP</code> will be used several more times during this guide.</p> <p>Run on your host machine to test ssh connection.</p> <pre><code>export RASPI_IP=pi@192.168.8.170\nssh-copy-id -i ~/.ssh/id_rsa.pub $RASPI_IP\nssh $RASPI_IP echo \"success\"\n# should echo success without prompting user to enter password\n</code></pre>"},{"location":"instrumentation/#kernel-compilation","title":"Kernel compilation","text":"<p>Prepare build environment.</p> <p>Ubuntu 20.04 LTS was used in this example.</p> <p>Install dependencies on your host machine and get source code.</p> <pre><code>sudo apt install crossbuild-essential-armhf     # default toolchain\nsudo apt install python-is-python3              # no python2 in ubuntu 20 fix\nsudo apt install bison flex\nsudo apt install qtbase5-dev pkg-config         # xconfig\nsudo apt install libncurses5-dev                # menuconfig\n\ncd git\ngit clone --depth=1 https://github.com/raspberrypi/linux\ncd linux\n# at the moment of writing we are using rpi-5.10.y branch specifically\n# 581049d718caf95f5feb00607ac748d5841cf27c commit\ngit checkout 581049d718caf95f5feb00607ac748d5841cf27c\n</code></pre> <p>Patch kernel</p> <p>For future debug output we add <code>CONFIG_DYNAMIC_DEBUG=y</code> to bcm2709_defconfig. The rest of this patch is the code instrumentation functions themself.</p> <p>instrument.patch</p> <p>Build kernel</p> <p>On your host machine:</p> <pre><code>cd git\ncd linux\nexport KERNEL=kernel7\n# output build directories\nexport BUILD_DIR=build\nexport INSTALL_PATH=install_tmp\n# temp directory for new content of the /boot and /root partion\nexport BOOT_PART_TMP=$BUILD_DIR/$INSTALL_PATH/boot\n\n# make modules_install will create build/install_tmp/root/lib directory during\n# install. we dont need to specify $BUILD_DIR prefix\nexport ROOT_PART_TMP=$INSTALL_PATH/root\n\n# prepare output directory\nmkdir -p $BOOT_PART_TMP\nmkdir -p $BOOT_PART_TMP/overlays\n\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j4 O=$BUILD_DIR bcm2709_defconfig\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j4 O=$BUILD_DIR scripts prepare modules_prepare\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j4 O=$BUILD_DIR zImage modules dtbs\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j4 O=$BUILD_DIR modules_install INSTALL_MOD_PATH=$ROOT_PART_TMP\n\n# export K_VERSION variable\nexport K_VERSION=$(make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- O=$BUILD_DIR -s kernelrelease)\n\ncp $BUILD_DIR/arch/arm/boot/zImage $BOOT_PART_TMP/$KERNEL.img\n\ncp $BUILD_DIR/arch/arm/boot/dts/*.dtb $BOOT_PART_TMP\ncp $BUILD_DIR/arch/arm/boot/dts/overlays/*.dtb $BOOT_PART_TMP/overlays\n</code></pre> <p>Deploy</p> <p>On your host machine:</p> <pre><code>export PI_HOME=/home/pi\n\ncd ~/git/linux\ntar -zcvf install_pkg.tar.gz $BUILD_DIR/$INSTALL_PATH\nscp install_pkg.tar.gz $RASPI_IP:/home/pi/\n\nssh $RASPI_IP tar -xvzf $PI_HOME/install_pkg.tar.gz\nssh $RASPI_IP rm $PI_HOME/install_pkg.tar.gz\nssh $RASPI_IP sudo cp -r $PI_HOME/build/install_tmp/root/lib/* /lib\nssh $RASPI_IP sudo cp -r $PI_HOME/build/install_tmp/boot/* /boot\nssh $RASPI_IP rm -rf $PI_HOME/build\nssh $RASPI_IP sudo reboot\n</code></pre> <p>Test if dynamic debug option is enabled</p> <pre><code>ssh $RASPI_IP sudo modprobe configs\nssh $RASPI_IP \"zcat /proc/config.gz | grep DYNAMIC_DEBUG\"\n# you should get the following output:\n# CONFIG_DYNAMIC_DEBUG=y\n# CONFIG_DYNAMIC_DEBUG_CORE=y\n</code></pre> <p>Build instrumented module</p> <pre><code>cd ~/git/linux\n\nexport BUILD_DIR=build\nexport K_VERSION=$(make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- O=$BUILD_DIR -s kernelrelease)\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j4 O=$BUILD_DIR -C . M=drivers/char/tpm EXTRA_CFLAGS=\"-g -DDEBUG=1 -finstrument-functions\"\n\nexport MOD_SRC=build/drivers/char/tpm\nexport MOD_TMP_DST=/home/pi\nexport MOD_DST=/lib/modules/$K_VERSION/kernel/drivers/char/tpm\n\nscp $MOD_SRC/tpm.ko $RASPI_IP:$MOD_TMP_DST/\nscp $MOD_SRC/tpm_tis_core.ko $RASPI_IP:$MOD_TMP_DST\nscp $MOD_SRC/tpm_tis_spi.ko $RASPI_IP:$MOD_TMP_DST\n\nssh $RASPI_IP sudo mv tpm.ko $MOD_DST;\nssh $RASPI_IP sudo mv tpm_tis_core.ko $MOD_DST;\nssh $RASPI_IP sudo mv tpm_tis_spi.ko $MOD_DST;\n</code></pre> <p>At this point, we need to enable device tree overlay for tpm.</p> <p>In Raspberry Pi ssh terminal:</p> <pre><code>sudo nano /boot/config.txt\n\n# add at the bottom\ndtparam=spi=on\ndtoverlay=tpm-slb9670\n\n# permanently enable debug log level\nsudo nano /boot/cmdline.txt\nadd 'loglevel=7' at the end of the line\n\n# reboot raspi\nsudo reboot\n</code></pre> <p>At this point, just after raspi reboot you should be able to see tpm function traces in <code>dmesg</code>.</p> <p>Example trace:</p> <p>In Raspberry Pi ssh terminal:</p> <pre><code>$ dmesg  | grep tpm_addr\n[    9.358361] tpm_addr_enter: 0x7f0ee070 0x801022a4\n[    9.358546] tpm_addr_enter: 0x7f0ee000 0x7f0ee15c\n[    9.359167] tpm_addr_exit: 0x7f0ee000 0x7f0ee15c\n[    9.359180] tpm_addr_exit: 0x7f0ee070 0x801022a4\n[    9.420744] tpm_addr_enter: 0x7f09f000 0x801022a4\n</code></pre>"},{"location":"instrumentation/#collect-traces-and-get-function-names-from-addresses","title":"Collect traces and get function names from addresses","text":"<p>Last step to get execution traces is to use provided scripts located in <code>ms-tpm-20-ref/Samples/Nucleo-TPM/scripts/kfunc_tracer</code></p> <p>Pull logs from your host machine:</p> <pre><code>$ ./pull_logs.sh\nRASPI_IP: pi@192.168.8.170\ncreating ./logs directory\nentering ./logs directory\ncleaning ./logs directory\ncollecting dmesg tpm_addr logs\ncollecting tpm related /proc/modules entries\n</code></pre> <p>Get function names. Below you can see the full call stack of tpm module failing due to not connected hardware of tpm module. To be executed on your host machine.</p> <pre><code>$ python get_call_stack.py\ntpm_tis_spi.ko: tpm_tis_spi_driver_probe()\ntpm_tis_spi.ko: tpm_tis_spi_probe()\ntpm_tis_spi.ko: tpm_tis_spi_init()\ntpm_tis_core.ko: tpm_tis_core_init()\ntpm.ko: tpmm_chip_alloc()\ntpm.ko: tpm_chip_alloc()\ntpm.ko: tpm2_init_space()\ntpm.ko: tpm2_init_space()\ntpm.ko: tpm_chip_alloc()\ntpm.ko: tpmm_chip_alloc()\ntpm_tis_core.ko: tpm_tis_clkrun_enable()\ntpm_tis_core.ko: tpm_tis_clkrun_enable()\ntpm_tis_core.ko: wait_startup()\ntpm_tis_spi.ko: tpm_tis_spi_read_bytes()\ntpm_tis_spi.ko: tpm_tis_spi_transfer()\ntpm_tis_spi.ko: tpm_tis_spi_flow_control()\ntpm_tis_spi.ko: tpm_tis_spi_flow_control()\ntpm_tis_spi.ko: tpm_tis_spi_transfer()\ntpm_tis_spi.ko: tpm_tis_spi_read_bytes()\ntpm_tis_core.ko: wait_startup()\ntpm_tis_core.ko: tpm_tis_clkrun_enable()\ntpm_tis_core.ko: tpm_tis_clkrun_enable()\ntpm_tis_core.ko: tpm_tis_remove()\ntpm_tis_core.ko: tpm_tis_clkrun_enable()\ntpm_tis_core.ko: tpm_tis_clkrun_enable()\ntpm_tis_spi.ko: tpm_tis_spi_read32()\ntpm_tis_spi.ko: tpm_tis_spi_read_bytes()\ntpm_tis_spi.ko: tpm_tis_spi_transfer()\ntpm_tis_spi.ko: tpm_tis_spi_flow_control()\ntpm_tis_spi.ko: tpm_tis_spi_flow_control()\ntpm_tis_spi.ko: tpm_tis_spi_transfer()\ntpm_tis_spi.ko: tpm_tis_spi_read_bytes()\ntpm_tis_spi.ko: tpm_tis_spi_read32()\ntpm_tis_spi.ko: tpm_tis_spi_write32()\ntpm_tis_spi.ko: tpm_tis_spi_write_bytes()\ntpm_tis_spi.ko: tpm_tis_spi_transfer()\ntpm_tis_spi.ko: tpm_tis_spi_flow_control()\ntpm_tis_spi.ko: tpm_tis_spi_flow_control()\ntpm_tis_spi.ko: tpm_tis_spi_transfer()\ntpm_tis_spi.ko: tpm_tis_spi_write_bytes()\ntpm_tis_spi.ko: tpm_tis_spi_write32()\ntpm_tis_core.ko: tpm_tis_clkrun_enable()\ntpm_tis_core.ko: tpm_tis_clkrun_enable()\ntpm_tis_core.ko: tpm_tis_remove()\ntpm_tis_core.ko: tpm_tis_core_init()\ntpm_tis_spi.ko: tpm_tis_spi_init()\ntpm_tis_spi.ko: tpm_tis_spi_probe()\ntpm_tis_spi.ko: tpm_tis_spi_driver_probe()\ntpm.ko: tpm_dev_release()\ntpm.ko: tpm_dev_release()\n</code></pre>"},{"location":"instrumentation/#whole-logs-from-the-test-procedure","title":"Whole logs from the test procedure","text":"<p>Below we have collected call stack for Raspberry Pi TPM driver startup. </p> <ul> <li>Log file with TPM module plugged in</li> <li>Log file without TPM</li> </ul>"},{"location":"issues/","title":"Current issues","text":""},{"location":"issues/#tpm2-tools-incompatibility-with-tty-devices","title":"tpm2-tools incompatibility with tty devices","text":"<p>tpm2-tools are not compatible with the current tpm implementation, which uses USB CDC, <code>/dev/tty*</code> device as a communication interface.</p> <p>This issue is probably caused, by the lack of <code>poll</code> function implementation is <code>tty</code> kernel driver. Apparently, tpm_tools expects a slightly different behavior and are designed to work with a particular tpm driver</p> <p>The actual line of code in <code>tpm-tss</code> library, causing failures in communication.</p> <pre><code>https://github.com/tpm2-software/tpm2-tss/blob/master/src/tss2-tcti/tcti-device.c#L466\n</code></pre> <p>Scripts are provided to make it easier to debug and investigate the behavior both for <code>tpm2-tools</code> and <code>tpm2-tss</code> <code>tpm2-pytss</code> libraries.</p> <p><code>simulator</code> - virtual serial port was created to act as a simulated tpm device, to capture commands, that tpm2-tools are sending. Those commands can be directly used, using <code>lpntpn_cmd</code> script.</p> <p><code>tpm2-pytss_example</code> - simple startup example using tpm2-pytss library</p> <p><code>tpm2-tts_example</code> - simple startup example using tpm2-tss library - has to be compiled with provided Makefile</p> <p>Some additional information could be found in Scripts readme file</p>"},{"location":"issues/#investigate-possible-security-issues","title":"Investigate possible security issues","text":"<p>As Jeremy Boone mention @ slack trusted-computing channel, we should investigate possible flaws in NVMem implementation.</p> <p>the _plat__ APIs in NVMem.c are where i\u2019ve seen the most mistakes. If you are persisting data to external flash then you need confidentiality, integrity, rollback-protection, and replay-protection.</p>"},{"location":"issues/#incoming-data-reception-and-decoding","title":"Incoming data reception and decoding","text":"<p>Data sent from VCOM application always get received as full command located in one incoming buffer. Parsing commands make use of this feature, letting the application execute only commands, that are received at once.</p> <pre><code>static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)\n{\n/* USER CODE BEGIN 6 */\nif(!TpmSignalEvent(Buf, Len))\n{\nreturn(USBD_FAIL);\n}\n...\n}\n</code></pre>"},{"location":"issues/#protocol-analysis-early-conclusions","title":"Protocol analysis - early conclusions","text":"<p>Getting STM32 to communicate with VCOM application leads us to a current yet not resolved problem.</p> <p>Right now we are able to execute commands on TPM, but an error occurs when the host device verifies the response data. Specifically, this line of code causes an error:</p> <pre><code>*((unsigned int*)&amp;response[sizeof(unsigned short) + sizeof(unsigned int)]) == 0\n</code></pre> <p>VCOM-TPM.cpp:198</p> <p>For now, it's not clear what the response data of TPM_Startup command should look like and what each byte of command represents.</p> <p>Command and response data looks as follows.</p> <pre><code>unsigned char CmdBuf[12] = {\n0x80, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x44, 0x00, 0x00\n};\n\nunsigned char RspBuf[12] = {\n0x80, 0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00\n};\n</code></pre> <p>This data is output via ITM trace on port 2.</p> <p>Correctness of data was verified on both sides of the communication.</p> <p>Startup command data is hardcoded in VCOM application here what makes it hard to reason about its origins.</p> <p>Raw data dumped from <code>CDC_Receive_FS</code> shows some similarities between VCOM sent command and test run of <code>tpm2_startup -T device:/dev/ttyACM1</code> application.</p> <p>VCOM Startup command received</p> <pre><code>0x54 0x70 0x6d 0x32 0x3 0x0 0x0 0x0 0x4 0x0 0x0 0x0 0xac 0x44 0x69 0x61\n0x54 0x70 0x6d 0x32 0x6 0x0 0x0 0x0 0x14 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0xc 0x0 0x0 0x0 0x80 0x1 0x0 0x0 0x0 0xc 0x0 0x0 0x1 0x44 0x0 0x0\n</code></pre> <p>tpm2_startup received command</p> <pre><code>0x80 0x1 0x0 0x0 0x0 0xc 0x0 0x0 0x1 0x44 0x0 0x1\n</code></pre> <p>As you can see VCOM sends much more bytes. Presumably two commands (?) as new the line gets appended to the log after a new pack of data gets received by <code>CDC_Receive_FS</code> function.</p> <pre><code>static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)\n{\nfor(int i=0; i&lt;*Len; i++) {\nitmPrintAppend(ITMSTDERR, \"0x%x \", Buf[i]);\n}\nitmPrintAppend(ITMSTDERR, \"\\n\");\n...\n}\n</code></pre> <p>What's interesting is the last 12 bytes of the received buffer, which differs only in the last byte between VCOM and tpm2_startup.</p> <p>Software simulator tpm-js shows exactly the same command and response data, as ITM debug output when using VCOM application.</p> <p>tpm-js output:</p> <pre><code>PowerOn\nManufactureReset\nStartup\nAbout to execute command TPM2_CC_Startup\nCommand buffer (12):\n  0000 80 01 00 00 00 0c 00 00 01 44 00 00              .........D..\nResponse buffer (10):\n  0000 80 01 00 00 00 0a 00 00 00 00                    ..........\n</code></pre> <p>ITM port 2 output:</p> <pre><code>//2021.10.14-08:52:37.000GMT\nunsigned char CmdBuf[12] = {\n0x80, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x44, 0x00, 0x00\n};\n//2021.10.14-08:52:37.330GMT\nunsigned char RspBuf[12] = {\n0x80, 0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00\n};\n</code></pre> <p>From what I discovered, the first 4 bytes of VCOM communication are the magic signal values from <code>TpmDevice.h</code></p> <pre><code>0x54 0x70 0x6d 0x32\n\n#define SIGNALMAGIC (0x326d7054) //Tpm2\n</code></pre> <p>For now, the rest of the protocol is to be discovered. Probably we should focus on getting <code>tpm2_tools</code> to work with STM32, as we probably don't want to port VCOM to Linux.</p> <p>This requires a better understanding of the communication protocol itself thus the following document will be helpful:</p> <p>TCG TSS 2.0 TPM Command Transmission Interface (TCTI) API Specification</p> <p>Section 1.3 Refedences</p> <p>TCG PC Client Platform TPM Profile (PTP) Specification</p> <p>Chapter 6</p> <p>TCG TSS 2.0 TPM Command Transmission Interface (TCTI) API Specification</p> <p>20.10.2021 update:</p> <p>The incoming data sent from VCOM application decodes as follows:</p> <pre><code>54 70 6d 32 6 0 0 0 14 0 0 0 0 0 0 0 c 0 0 0 80 1 0 0 0 c 0 0 1 44 0 0\n</code></pre> <pre><code>sizeof(signalWrapper_t)\n{\nsig-&gt;s.magic    '\\x54\\x70\\x6d\\x32'  uint32_t hardcoded magic value\nsig-&gt;s.signal   '\\x06\\x00\\x00\\x00'  uint32_t signal enum\nsig-&gt;s.dataSize '\\x14\\x00\\x00\\x00'  uint32_t data size\n}\nsizeof(unsigned int) * 2)\n{\n'\\x00\\x00\\x00\\x00'          uint32_t locality\n'\\x0c\\x00\\x00\\x00'          uint32_t cmdSize\n}\nactual TPM command          Global.h:1098\n'\\x80\\x01'              TPM_ST           command.tag;\n'\\x00\\x00'\\x00\\x0c'         UINT32           commandSize;\n'\\x00\\x00\\x01\\x44'          TPM_CC           command.code\n'\\x00\\x00'\n</code></pre> <p>Probably all of those header values are redundant and should be decoded using unmarshal mechanism.</p>"},{"location":"issues/#memory-usage","title":"Memory usage","text":"<p>Memory limitations hit us right at the beginning preventing us from building the project for STM32L476RG on both Linux STM32CubeIDE and Windows Atollic Studio.</p> <p>After limiting the minimal stack size in the linker script the application fits in SRAM memory, but probably the problem will hit us soon after successful execution of TPM command.</p> <p></p> <p>At the moment of writing, we are almost out of memory. </p>"},{"location":"issues/#outdated-repository","title":"Outdated repository","text":"<p>After struggling a lot with build errors while compiling the <code>master</code> branch we decided to roll back the repo.\u00a0Chosen commit is the one, that adds STM32 samples. Plans involve updating the repo, eventually hitting most actual changes.</p>"},{"location":"issues/#differences-between-stm32-and-simulator-implementation-of-command-parsing","title":"Differences between STM32 and Simulator implementation of command parsing","text":"<p>Dealing with the actual communication with TPM core we are facing some minor problems.</p> <p>VCOM application dedicated to TPM communication, located in <code>ms-tpm-20-ref/Samples/Nucleo-TPM/VCOM</code> is created using Windows, so we have to decide if we want to port it.</p> <p>Data packet for controlling the TPM differs between one used by <code>tpm2_tools</code>, Simulator, and STM32 implementation.</p> <p>This point needs additional investigation, but a quick glance at received data sent by using <code>tpm2_startup -T device -d/dev/ttyACM1 --state</code> command ensures us about it. By /dev/ACM1 port we mean STM32 USB CDC.</p>"},{"location":"issues/#possible-bug-in-build-system","title":"Possible bug in build system","text":"<p>According to the project assumptions, whole configuration is done using <code>user_settings.h</code> file. Previously encountered error led us to the conclusion that some parts of the aplication could be misconfigured.</p> <p>Some of the build switches inside <code>TpmBuildSwitches.h</code> could be enabled in an unwanted way.</p> <p>It needs to be further investigated with defines like <code>SIMULATION</code> and <code>SELF_TESTS</code> in mind. Maybe we can get some extra free RAM space this way.</p>"},{"location":"journal/","title":"Journal","text":"<p>04-08.10.2021</p> <ul> <li>Fixing compilation problems.</li> <li>Converting project to STM32CubeIDE.</li> <li>Setup ITM trace logging.</li> </ul> <p>11-15.10.2021</p> <ul> <li>Getting USB CDC work.</li> <li>Experiments with tpm2-tools.</li> <li>Writing documentation.</li> <li>Investigation of memory usage and choosing best suited hw platform.</li> </ul> <p>14.10.2021</p> <ul> <li>Building and running VCOM project <code>Samples/Nucleo-TPM/VCOM</code> (Visual Studio 2017).</li> <li>First successful communication with TPM core.</li> <li>Investigation the root cause of response check failing. link</li> </ul> <p>15.10.2021</p> <ul> <li>Small fix for NDEBUG enabled compilation.</li> <li>Protocol analysis.</li> </ul> <p>18.10.2021</p> <ul> <li>Protocol analysis.</li> </ul> <p>19.10.2021</p> <ul> <li>Protocol analysis</li> <li>Decoding command and response data frames.</li> <li>Setting up lib tpm2-tss and tpm2-pytss for future communication.</li> </ul> <p>20/21.10.2021</p> <ul> <li>Protocol analysis.</li> <li>Investigation of lib tpm2-tss and tpm2-pytss behavior and wrong packet reception.</li> </ul> <p>26.10.2021</p> <ul> <li>USB communication reworked, added circular buffer and functions responsible for command validation.</li> <li>Development of python scripts responsible for serial communication and investigation the root cause of tpm2_tool @ /dev/ACM* failures.</li> </ul> <p>27.10.2021</p> <ul> <li>Cleanup and refactor of python scripts.</li> <li>Writing documentation.</li> </ul> <p>28.10.2021</p> <ul> <li>Kernel development setup.</li> <li>Browsing tpm related kernel code.</li> </ul> <p>02.11.2021</p> <ul> <li>Writing docs.</li> <li>Function profiler prototype refactor.</li> <li>Experimenting with tpm module debug build.</li> </ul> <p>03.11.2021</p> <ul> <li>Investigation of dynamic debug behavior.</li> <li>Writing how-to for kernel module recompilation.</li> </ul> <p>04.11.2021 - Writing how-to for kernel instrumentation.   https://github.com/lpn-plant/lpntpm-docs/pull/7</p> <p>05-09.11.2021 - Raspberry Pi / STM32 SPI communication. - TPM SPI specification research.</p> <p>12.11.2021 - TPM SPI specification research.</p> <p>22.11.2021 - Hardware interfaces requirements - documentation.   https://github.com/lpn-plant/lpntpm-docs/pull/6/files</p> <p>10.11.2021</p> <ul> <li>Raspberry Pi demonstration with TPM module</li> </ul>"},{"location":"rpi/","title":"This chapter shows the TPM test procedure using the Raspberry Pi 3 module","text":""},{"location":"rpi/#lets-trust-tpm-information","title":"Lets Trust TPM Information","text":""},{"location":"rpi/#1-product-contents","title":"1. Product contents","text":"<ol> <li> <p>LetsTrust TPM Module (12.7 x 17.5 mm)</p> </li> <li> <p>Female header (2x8 pin)</p> </li> </ol>"},{"location":"rpi/#2-install-letstrust-tpm-module","title":"2. Install LetsTrust TPM module","text":"<p>Installation precedure : </p> <ul> <li>First, insert the additional female header starting with pin 1 (on the far left side) into the Raspberry Pi GPIO header. The supplied female header helps to plug in the TPM module in the right position. After mounting it, could be removed. </li> <li>Insert the Letstrust TPM module directly next to the additional female header.  The TPM module will be installed starting with pin 17, facing downwards  with the chip and oriented towards the HDMI port. </li> </ul> <p></p> <p>The LetsTrust TPM module is also compatible with other Raspberry Pi modules.</p> <p>All connections should be done while the power supply is switched OFF! </p>"},{"location":"rpi/#3-usage-examples","title":"3. Usage examples","text":"<p>The best projects for the TPM module come from the community in which the Letstrust supplied the hardware. Already, several core software packages are available:</p> Link Description http://github.com/tpm2-software Tools to use the TPM https://github.com/Infineon/eltt2 ELTT2 Infineon Embedded Linux TPM Toolbox 2 for TPM 2.0 - test, diagnostics and essential changing of the Infineon TPM chip  p https://github.com/PaulKissinger/LetsTrust Useful resources and script to get you started with the TPM and compilation/installation of the TPM 2.0 Tools. <p>Application samples, documentation, and a lot of additional information from the community are available at www.letsTrust.de.</p> <p>To report your examples and develop applications send an e-mail at support@pi3g.com or info@letstrust.de.</p>"},{"location":"rpi/#first-install-the-tpm2-tools","title":"First, install the tpm2-tools","text":"<pre><code>sudo apt install tpm2_tools\n</code></pre> <p>After that you could run all the tools which are described at: tpm2-tools /man/ For example: </p> <ul> <li>Example 1:</li> </ul> <pre><code>sudo tpm2_pcrread\n</code></pre> <p> </p> <ul> <li>Example 2:</li> </ul> <pre><code>sudo tpm2_getcap -l\n</code></pre> <p></p> <ul> <li>Example 3:</li> </ul> <pre><code>sudo readclock\n</code></pre> <p></p>"},{"location":"rpi_connection/","title":"Connecting Raspberry Pi 3 with Windows OS using USB/UART converter","text":"<p>For make this task necessary are:</p> <ul> <li> <p>Raspberry Pi 3 Model B</p> </li> <li> <p>USB/UART Converter</p> </li> <li> <p>TPM module</p> </li> <li> <p>PC with Windows OS</p> </li> </ul> <p></p>"},{"location":"rpi_connection/#guide","title":"Guide","text":"<ul> <li> <p>The first step is Raspberry Pi OS installation using Imager program. Please choose: Download for Windows </p> </li> <li> <p>Please download the OS: RPI OS</p> </li> <li> <p>Connect the SD card reader to the USB port and run the file flashing procedure  via Imager software.</p> </li> <li> <p>Find and edit config.txt file. Please make sure that after edit you have one more additional line as the line below:</p> </li> </ul> <pre><code>enable_uart=1\n</code></pre> <p>Recommended is to add the above line at the bottom of the config.txt file. </p> <ul> <li> <p>After that plug uSD card into the Raspberry Pi socket. Make sure that your converter has the right voltage support! 3.3V is recommended!</p> </li> <li> <p>Connect the USB/UART converter to the USB port at your PC. </p> </li> <li> <p>Run PuTTY.</p> </li> <li>Set the parameters as below. Important is to choose the serial option, the right COM port and speed.*</li> </ul> <p></p> <p></p> <p>After that open the serial port and plug the power supply into your RPi. Now you will work in the terminal.</p> <ul> <li>Log into Raspberry Pi. The default login is: pi and password: raspberry.</li> </ul>"},{"location":"rpi_connection/#configuration-and-activation-under-raspbian","title":"Configuration and activation under Raspbian","text":"<p>The LetsTrust TPM module is supported directly by Linux, starting with Kernel 4.14.85. Please refer to www.letsTrust.de for further information. Update to the latest Raspbian Stretch and active the TPM as /dev/tpm0 using the following commands:</p> <pre><code>$ sudo apt-get update &amp;&amp; sudo apt-get upgrade\n$ sudo nano /boot/config.txt\n</code></pre> <p>Necessary is to add these two lines at the bottom of the document:</p> <pre><code>dtparam=spi=on\ndtoverlay=tpm-slb9670\n</code></pre> <pre><code>$ sudo reboot\n</code></pre> <p>To make sure that the initialization process was successful please check if you have available:</p> <pre><code>/dev/tpm0\n</code></pre>"},{"location":"rpi_faq/","title":"FAQ &amp; Good to know","text":""},{"location":"rpi_faq/#which-chip-does-the-tpm-use","title":"Which chip does the TPM use?","text":"<p>Let's Trust TPM module https://www.pi3g.com use the Infineon OPTIGA SLB 9670 TPM 2.0 Firmware 7.85 or later. This chip is compliant with the TCG TPM 2.0 Specification, revision 1.38. Starting with Firmware Version 7.85 the SLB 9670 is certified with Common Criteria EAL4+ and FIPS 140-2.</p>"},{"location":"rpi_faq/#can-spi-still-be-used","title":"Can SPI still be used?","text":"<p>Yes, CS0 can still be used, the TPM module uses CS1. It is possible to address the TPM module using CS0, by satisfying both conditions: </p> <ul> <li>moving the 0-Ohm resistor from position R3 to R2, </li> <li>patching the device tree overlay to talk to the module on CS0. The component placing can be found at: https://www.letstrust.de/uploads/letstrust-v2.0.placement.pdf</li> </ul>"},{"location":"rpi_faq/#can-i-download-a-circuit-diagram","title":"Can I download a circuit diagram?","text":"<p>The circuit diagram is available at: https://www.letstrust.de/uploads/letstrust-v2.0schematic.pdf</p>"},{"location":"rpi_faq/#how-do-i-get-support","title":"How do I get support?","text":"<p>Many topics could be found at https://www.letsTrust.de For more information in-depth questions, please get in touch with support: suport@pi3g.com</p>"},{"location":"rpi_faq/#can-you-supply-a-custom-version-of-the-tpm-module","title":"Can you supply a custom version of the TPM module?","text":"<p>Starting at just 100 modules Trust TPM can modify the design for special requests. More information at: suport@pi3g.com</p>"},{"location":"running/","title":"Running","text":"<p>The project is using three communication interfaces to debug and talk to TPM core.</p> <ul> <li>TPM core communication is handled by STM32 USB CDC interface. See <code>https://github.com/microsoft/ms-tpm-20-ref/blob/master/Samples/Nucleo-TPM/USB_Hookup.jpg</code></li> <li><code>printf</code> is forwarded to the integrated STLink VCOM.</li> <li><code>fprintf(stderr, *)</code> could be received on port 0 of ITM SWV.</li> <li><code>dbgPrint</code> uses port 1 of  ITM SWV.</li> </ul>"},{"location":"running/#itm-trace-configuration","title":"ITM trace configuration","text":"<p>For now, ITM trace output is available only through STM32CubeIDE. We are planning to add this feature using command-line tools like <code>openocd</code> or <code>STM32_Programmer_CLI</code>.</p> <p>To view ITM output first you should enable SWV ITM console, by selecting it in <code>Window -&gt; Show View -&gt; Other</code>.</p> <p>Next thing is to start to debug the application and when it hits the first breakpoint select <code>Configure trace</code> under SWV ITM console.</p> <p></p> <p>Select the first three channels and accept.</p> <p></p> <p>After that you should be ready to go, so just click <code>Start Trace</code> - red dot icon and hit F8 to continue program execution.</p> <p></p> <p>Now you should see trace debug output like in the picture below.</p> <p></p>"},{"location":"running/#usb-cdc-configuration","title":"USB CDC configuration","text":"<p>On some platforms (Ubuntu in my case) '/dev/ttyACM*' ports automatically receive AT commands just after plugging USB cable.</p> <p>As we are using raw data format to communicate with TPM device and STM32 CDC port mount as /dev/ACM* device this could be problematic.</p> <p>To stop receiving AT commands just disable ModemManager service with the following command:</p> <pre><code>systemctl stop ModemManager\nsudo systemctl disable ModemManager\n</code></pre>"},{"location":"running/#sample-command-execution","title":"Sample command execution","text":"<p>As being said, the communication to the TPM core is done using Nucleo's USB CDC Port. In the original implementation VCOM - Windows application was created for this purpose. We choose a different approach and provide several ways to talk to a TPM. Host applications and scripts for experimenting with the protocol are located in <code>ms-tpm-20-ref/Samples/Nucleo-TPM/scripts</code> directory.</p> <pre><code>scripts\n|   lpntpn_cmd              - main python script for tpm communication\n|                             see ./lpntpn_cmd --help for more info\n|   README.md\n|   simulator               - serial port simulator for future protocol\n|                             and tpm2-tools/tpm2-tss anallisis\n|\n|   tpm2-pytss_example      - simple startup example using tpm2-pytss library\n|\n\u2514\u2500\u2500\u2500tpm2-tts_example        - simple startup example using tpm2-tss library\n|\n\u2514\u2500\u2500\u2500utils\n</code></pre> <p>For now only <code>lpntpn_cmd</code> is able to execute its full commands without any errors. pytss and tss examples were created for future communication with tpm device and right now are failing, probably due to not implemented <code>pool</code> functionality in <code>tty</code> kernel driver. More on that on Current issues page.</p> <p>At the moment of writing, only <code>startup</code> and <code>shutdown</code> commands were implemented. As the original implementation adds some redundant data to the protocol, <code>--legacy | --no-legacy</code> arguments were added to <code>lpntpn_cmd</code> application, to allow the user to send VCOM compatible legacy commands.</p> <p>Reception of such legacy commands requires commenting out <code>#define NEW_SIGNAL_HANDLING</code> macro in main.c file, as it is defined by default.</p> <p>Otherwise simple call to <code>./lpntpn_cmd</code> should be enough to be able to execute <code>startup</code> command on lpntpn.</p> <p>Before running host-side applications, you should flash and start STM32 binary, with debug prints reception enabled with ITM ports 0,1,2 as mentioned in ITM trace configuration</p> <p>Succesfull execution, should result in the following console output:</p> <pre><code>$ ./lpntpn_cmd\nrunning in non legacy mode...\non /dev/ttyACM1 serial port...\nexecuting startup command...\n     sending: b'\\x80\\x01\\x00\\x00\\x00\\x0c\\x00\\x00\\x01D\\x00\\x00'\nwaiting for response...\n     received: bytearray(b'\\x80\\x01\\x00\\x00\\x00\\n\\x00\\x00\\x01\\x00')\n</code></pre> <p>And following output in SWV ITM Data window</p> <pre><code>ITM port 0:\n\n=========================\n= Nucleo-L476RG TPM 2.0 =\n=========================\n2000.01.02-10:10:40.441GMT: Generated tpmUnique\n    875fcea802b97786efd69cb3c1f1371b\n    70d465d97b8c52532c3ba603f2fa571b\n    ef6c44634a2910b303ef92a5d05a59f8\n    adbc978cca2f2f9874b4e5a2216c10ec\n2000.01.02-10:10:40.573GMT: NVFile loaded (16kb, 2000.01.01-03:23:25GMT created, 84 writes, 2000.01.02-10:02:27GMT last)\n2000.01.02-10:10:40.576GMT: _plat__SetNvAvail().\n2000.01.02-10:10:40.576GMT: _plat__Signal_PowerOn().\n2000.01.02-10:10:40.576GMT: _plat__Signal_Reset().\n2000.01.02-10:10:40.711GMT: NVFile loaded (16kb, 2000.01.01-03:23:25GMT created, 84 writes, 2000.01.02-10:02:27GMT last)\n2000.01.02-10:10:40.714GMT: CDC_SET_LINE_CODING: 9600-8N1\n2000.01.02-10:10:51.507GMT: CDC_SET_CONTROL_LINE_STATE: RTS=1, DTR=1\n2000.01.02-10:10:51.507GMT: CDC_SET_LINE_CODING: 115200-7N2\n2000.01.02-10:10:51.723GMT: Executing command TPM_CC_Startup()\n2000.01.02-10:10:52.306GMT: NVFile written (16kb, 2000.01.01-03:23:25GMT created, 85 writes, 2000.01.02-10:10:52GMT last)\n2000.01.02-10:10:52.309GMT: Completion time 0'1\" with ReturnCode {TPM_RC_SUCCESS}\n2000.01.02-10:10:52.315GMT: CDC_SET_CONTROL_LINE_STATE: RTS=0, DTR=0\n\nITM port 1:\n\n2000.01.02-10:10:51.723GMT: SignalCommand(12)\n2000.01.02-10:10:52.309GMT: Response(10)\n\nITM port 2:\n\n//2000.01.02-10:10:51.723GMT\nunsigned char CmdBuf[12] = {\n0x80, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x44, 0x00, 0x00\n};\n//2000.01.02-10:10:52.309GMT\nunsigned char RspBuf[10] = {\n0x80, 0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00\n};\n</code></pre> <p>An example, changing command type, serial port, and enabling legacy mode.</p> <pre><code>./lpntpn_cmd --port /dev/ttyACM0 --command shutdown --legacy\nrunning in legacy mode...\non /dev/ttyACM0 serial port...\nexecuting shutdown command...\n     sending: b'Tpm2\\x06\\x00\\x00\\x00\\x14\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x80\\x01\\x00\\x00\\x00\\x0c\\x00\\x00\\x01E\\x00\\x00'\nwaiting for response...\n</code></pre>"},{"location":"sparkfun-thingplus/","title":"Developing on SparkFun Thing+ board","text":"<p>SparkFun Thing+ is a board based on, and compatible with QuickLogic FeatherLite board. It has EOS S3 which is ARM Cortex-M4 MCU with embedded FPGA. See this link for official documentation.</p>"},{"location":"sparkfun-thingplus/#first-boot","title":"First boot","text":"<p>Device comes pre-flashed with diagnostic firmware, when device boots it flashes blue led for a few seconds, then pressing reset button will trigger diagnostic firmware and device exposes serial port over USB (CDC ACM).</p>"},{"location":"sparkfun-thingplus/#flashing-firmware-to-device","title":"Flashing firmware to device","text":"<p>Flashing can be performed in two way, either through bootloader or through SWD. Bootloader flashing mode can be triggered by pressing the reset button followed by pressing the user button. Green LED should start breathing. If LED blinks blue and green then an error has occurred (this happened on the firmware that came pre-installed on the device, flashing through SWD was required).</p> <p>Device came with broken firmware version, which prevents firmware flashing, please see Recovering from bad flash section - recovery process involves reflashing bootloader and USB FPGA with a working properly working version.</p> <p>Note: original bootloader version had a weird quirk - having UART connected, was causing bootloader to actually enter download mode, however attempt to flash m4app resulted in corrupting bootloader and USB FPGA.</p>"},{"location":"sparkfun-thingplus/#flashing-through-openocd","title":"Flashing through OpenOCD","text":"<p>For flashing through OpenOCD following equipment is required</p> <ul> <li>Debugger supporting OpenOCD, e.g.   Olimex ARM-USB-OCD-H   (requires also ARM-JTAG-SWD   adapter)</li> <li>SWD cable</li> </ul> <p>When flashing firmware over SWD you need to put jumpers on J2 and J3. You need OpenOCD version 0.11, if your distro provides older version you have to build OpenOCD yourself.</p> <pre><code>apt build-dep openocd\ngit clone https://github.com/openocd-org/openocd --branch v0.11.0 --depth=1\ncd openocd\n./bootstrap\nmkdir build &amp;&amp; cd build\n../configure --prefix=/opt/openocd\nmake -j$(nproc)\nmake install\n</code></pre> <p>Flash device is an external SPI flash and OpenOCD can't handle it - in order to write flash bootloader is required. Prebuilt bootloader is available here, source is also available in qorc-sdk repo.</p> <p>Clone repository with prebuilt bootloader</p> <pre><code>git clone https://github.com/QuickLogic-Corp/quick-feather-dev-board\n</code></pre> <p>Connect board to debugger using SWD cable, make sure jumpers are in place, plug USB cable and then type the following command</p> <pre><code>/opt/openocd/bin/openocd -f interface/ftdi/olimex-arm-usb-ocd-h.cfg \\\n-f interface/ftdi/olimex-arm-jtag-swd.cfg \\\n-f board/quicklogic_quickfeather.cfg \\\n-c init \\\n-c reset \\\n-c \"load_image quick-feather-dev-board/binaries/qf_loadflash.bin 0x0 bin\" \\\n-c reset \\\n-c exit\n</code></pre> <p>Green LED should immediatelly light up and host should detect new CDC ACM device</p> <pre><code>[881016.294497] usb 3-2: new full-speed USB device number 25 using xhci_hcd\n[881016.443375] usb 3-2: New USB device found, idVendor=1d50, idProduct=6130, bcdDevice= 0.00\n[881016.443384] usb 3-2: New USB device strings: Mfr=0, Product=0, SerialNumber=0\n[881016.445132] cdc_acm 3-2:1.0: ttyACM0: USB ACM device\n</code></pre> <p>Now device can be flashed through USB.</p>"},{"location":"sparkfun-thingplus/#preparing-flashing-tools","title":"Preparing flashing tools","text":"<p>Firmware can be flashed through QuickLogic's TinyFPGA programmer fork. Please follow the instructions below to prepare programmer.</p> <pre><code>git clone https://github.com/QuickLogic-Corp/TinyFPGA-Programmer-Application --recurse-submodules\ncd TinyFPGA-Programmer-Application\ngit checkout 97149cab9126e70cc1aeeca6ba023520ae18ce60\npip3 install tinyfpgab\nsed -i 's@^#!python3\\.7@#!/usr/bin/env python3@' tinyfpga-programmer-gui.py\nchmod +x tinyfpga-programmer-gui.py\n</code></pre> <p>Programmer cannot be easily installed because has no setuptools script, unless you want to copy to script (including submodules) into your bin, please consider putting an alias into your <code>.bashrc</code></p> <pre><code>alias qfprog=\"/full/path/to/tinyfpga-programmer-gui.py\"\n</code></pre> <p>Install <code>71-QuickFeather.rules</code>, otherwise qfprog may conflict with ModemManager (which may detect device as GSM modem).</p> <pre><code>sudo cp 71-QuickFeather.rules /etc/udev/rules.d/\nsudo udevadm control --reload\n</code></pre> <p>Unplug and plug device back in for the changes to take effect.</p>"},{"location":"sparkfun-thingplus/#running-zephyr-hello-world","title":"Running Zephyr hello world","text":"<p>To avoid messing with your environment you may use official Zephyr container.</p> <pre><code>$ mkdir zephyr\n$ cd zehpyr\n$ docker run -it \\\n--privileged \\\n-v /dev:/dev \\\n-u $(id -u) \\\n-v $PWD:/workdir \\\nghcr.io/zephyrproject-rtos/zephyr-build:v0.23.3\n(docker)$ west init .\n(docker)$ west update\n(docker)$ west build -b quick_feather zephyr/samples/hello_world\n</code></pre> <p>To flash Zephyr you need to enter download mode, either by pressing the user button or by downloading bootloader through OpenOCD which has been described in sections above. Then to flash Zephyr use the following command</p> <pre><code>qfprog --mode m4 --m4app build/zephyr/zephyr.bin\n</code></pre> <p>To boot from flash you need to take off jumpers and also to boot into Zephyr you need press reset button.</p> <p>Zephyr by default outputs to UART0 instead of UART-over-USB (USB even isn't enabled when Zephyr boots). To be able to see anything you have to connect UART to <code>44/TX</code> and <code>45/RX</code> pins on J6 connector (you may also see official documentation linked at the top of this document).</p> <p>Qorc SDK has an example app (<code>qf_uart2usbser</code>) which may be used to get USB UART working on Zephyr.</p>"},{"location":"sparkfun-thingplus/#other-components-bootloader-fpgas","title":"Other components, bootloader, FPGAs","text":"<p>QuickLogic EOS comes with few components available as part of Qorc SDK</p> <ul> <li>Bootloader (<code>qf_bootloader</code>) - Cortex-M4 application responsible for booting   platform and loading FPGAs.</li> <li>Cortex-M4 - target application to run on Cortex-M4, Qorc SDK contains a few   applications, including <code>qf_helloworldsw</code> which is the diag application that   comes preinstalled.</li> <li>bootfpga - this is USB serial FPGA. See the section below for how to recover.</li> <li>FPGA for user application - FPGA which can be used for any purpose.</li> </ul> <p></p> <p>Qorc SDK comes with <code>envsetup.sh</code> script that automatically downloads all required components (compilers, etc.) and configures environment, tested on Ubuntu 20.04 with Qorc SDK rev <code>6968338b8778cb129ae441f6944444c9a1298390</code>.</p> <p><code>qfprog</code> can flash a few types of image</p> <pre><code>usage: tinyfpga-programmer-gui.py [-h] [--mode [fpga-m4]] [--m4app app.bin] [--appfpga appfpga.bin] [--bootloader boot.bin] [--bootfpga fpga.bin] [--reset] [--port /dev/ttySx] [--crc] [--checkrev]\n[--update] [--mfgpkg qf_mfgpkg/]\n\noptional arguments:\n  -h, --help            show this help message and exit\n--mode [fpga-m4]      operation mode - m4/fpga/fpga-m4\n  --m4app app.bin       m4 application program\n  --appfpga appfpga.bin\n                        application FPGA binary\n  --bootloader boot.bin, --bl boot.bin\n                        m4 bootloader program WARNING: do you really need to do this? It is not common, and getting it wrong can make you device non-functional\n  --bootfpga fpga.bin   FPGA image to be used during programming WARNING: do you really need to do this? It is not common, and getting it wrong can make you device non-functional\n  --reset               reset attached device\n  --port /dev/ttySx     use this port\n  --crc                 print CRCs\n  --checkrev            check if CRC matches (flash is up-to-date)\n--update              program flash only if CRC mismatch (not up-to-date)\n--mfgpkg qf_mfgpkg/   directory containing all necessary binaries\n</code></pre> <p>For device to boot, bootloader, m4app and bootfpga partitions are required. Bootfpga is actually USB serial FPGA and it is required for programming device and for booting application that use serial over USB.</p>"},{"location":"sparkfun-thingplus/#recovering-from-bad-flash","title":"Recovering from bad flash","text":"<p><code>qf_loadflash</code> doesn't require a valid USB serial FPGA in SPI flash as it contains its own embedded USB FPGA, so it can be used for recovering from corrupted flash.</p> <p>To recover from bad flash you have to flash <code>bootloader</code> and <code>bootfpga</code>. <code>qf_bootfpga</code> provided in <code>quick-feather-dev-board</code> repo is broken and device will hang when attempting to load, but <code>qf_bootfpga</code> can be built as part <code>qf_bootloader</code>. To built it go to <code>qorc-sdk</code> directory, run <code>envsetup.sh</code>, then go to <code>qf_apps/qf_bootloader</code> and run <code>make</code>. Then flash resulting binaries</p> <pre><code>qfprog --mode m4 --bootloader GCC_Project/output/qf_bootloader.bin\nqfprog --mode m4 --bootfpga GCC_Project/output/qf_bootfpga.bin\n</code></pre>"},{"location":"sparkfun-thingplus/#fpga-synthesis","title":"FPGA synthesis","text":"<p>QuickLogic uses its own SymbiFlow fork for synthesis. <code>qorc-sdk</code> contains Verilog sources for usb2serial among others (located in <code>s3-gateware</code> directory). Sources for many components can built without problems by simply running <code>make</code>.</p>"},{"location":"sparkfun-thingplus/#fpga-demo-applications","title":"FPGA demo applications","text":"<p><code>qf_apps</code> contains a few applications using a custom FPGA, including <code>qf_helloworldhw</code> and <code>qf_advancedfpga</code>. These applications can be flashed through bootloader as any other application.</p> <p>Despite using FPGA, the two applications must be flashed in m4 mode. <code>qf_advancedfpga</code> uses UART0 instead of USB. Applications must be told to power on the LED, please see Qorc SDK readme</p> <p>QuickLogic has 3 modes of operation: <code>m4</code>, <code>fpga</code> and <code>fpga-m4</code>. This controls bootloader behaviour, so that bootloader loads either Cortex-M4 application, FPGA or both. In case of applications that load FPGA by themselves, mode should be <code>m4</code>.</p> <p>Note: You can use <code>qfprog --mode</code> to get current mode.</p> <p>If operation mode is set to <code>fpga</code> or <code>fpga-m4</code> bootloader loads FPGA from the <code>appfpga</code> region, see relevant code here</p>"},{"location":"sparkfun-thingplus/#resources","title":"Resources","text":"<ul> <li>Thing+ guide -   Getting started for Sparkfun Thing+, contains HW overview, including images   and detailed pin descriptions, schematics and other useful resources.</li> </ul>"},{"location":"symbiflow_investigation/","title":"Open-source tools for FPGA synthesis","text":""},{"location":"symbiflow_investigation/#getting-acquainted-with-the-open-source-symbiflow-package-for","title":"Getting acquainted with the open-source \"Symbiflow\" package for","text":"<p>synthesizing, implementing and generating the FPGA configuration file</p> <p>Here is a link to the main Github repository for the Symbiflow software package:</p> <p>Github Symbiflow repository</p> <p>First, I installed a modified version of the Yosys package (modifications for Symbiflow) from this report:</p> <p>Github Yosys Symbiflow repository</p> <p>Installation carried out according to the instructions on the main page of this repository. Yosys is only for FPGA synthesis phase. A list of Verilog primitive connections is created in JSON format.</p> <p>The next tool is for the implementation phase (map processes, placement and routing). For this phase you need a \"user constaraints\" file in Pcf format for the selected FPGA.</p> <p>Here is the link to the nextpnr tool repository used to implement and create a \"bitstream\" (binary configuration file) for a given FPGA chip:</p> <p>Github nextpnr Symbiflow repository</p> <p>ATTENTION! - installations should be performed according to the instructions on the Github repository page, it requires for different FPGA families (Lattice, Xilinx - Intel is not supported at all), installation of additional Symbiflow packages. For example, for the ICE40 family of the IceStorm project Lattice from this repository:</p> <p>IceStorm ICE40 project repository</p> <p>I installed all the additional tools for the FPGA families:</p> <ul> <li>Lattice ICE40 (low resource FPGAs)</li> <li>Lattice ECP5 (medium-sized FPGAs - equivalent to Xilinx's Artix-7 family)</li> <li>Gowin FPGAs (unfortunately there were errors during the installation and the package probably does not work)</li> <li>Generic FPGAs - you can define your own types of FPGAs here - but it is very complex.</li> </ul> <p>Since package installations are done by compiling the sources from a repository, it takes a few hours to install all packages.</p> <p>I also installed the vtr-verilog-to-routing package which is used for the implementation phase and bitstream generation for Xilinx's Artix-7 family chips. Unfortunately, after watching the video tutorial presenting the status of the Symbiflow project, I know that the bitstream generation support for Xilin chips is very incomplete (eg it does not include clock pins and Block_RAM memory, which are used in practically every project. X-Ray package needed to generate bitstream also requires \"Xilinx Vivado\" to be installed in the archived version 2017.2 (the installer package that you need to download from the Xilinx website is about 20 GB).</p> <p>Here is the link to the video tutorial on Symbiflow (I think you must watch it): Youtube video tutorial for Symbiflow</p> <p>It shows that VHDL support is very limited in Symbiflow, and that bitstream generation for all primitives of a given FPGA family is full only for Lattice's ICE40 chips. It's also not bad for the Lattice ECP5 family. The bitstream generation for Xilinx's Artix-7 family of FPGAs is partial.</p>"},{"location":"symbiflow_investigation/#an-attempt-to-implement-and-generate-bitstream-for-the-lattice-ice40","title":"An attempt to implement and generate bitstream for the Lattice ICE40","text":"<p>family of FPGAs</p> <p>Since full support for FPGA implementation and bitstream generation is available for Lattice's ICE40 chips, I decided to make the first trial for such a chip.</p> <p>The implementation and bitstream generation for a simple example of LED blinking (Hello world for FPGA devices) was carried out according to the tutorial from the project website nextpnr:</p> <p>Github nextpnr Symbiflow repository</p> <p>I launched the Linux console and went to the directory /home /bofh/Symbiflow/ nextpnr/ice40/ examples where I installed the nextpnr package: Then I ran these commands:</p> <p>cd / blinky</p> <p>yosys -p 'synth_ice40 -top blinky -json blinky.json' blinky.v # synthesize into blinky.json</p> <p>nextpnr-ice40 --hx1k --json blinky.json --pcf blinky.pcf --asc blinky.asc # run place and route</p> <p>icepack blinky.asc blinky.bin # generate binary bitstream file</p> <p>Before executing the commands, there were only the following files in the blinky directory: + blinky.v - verilog code of the main module of the project + blinky_tb.v - test-bench for the main module + blinky.pcf - \"user constraints\" file describing the pin mapping of the ICE40 FPGA chip for the project</p> <p>All phases of the project ended without any errors being reported, and the bitstream blinky.bin file was created.</p> <p>After this trial, I decided to implement some more complex Verilog project, consisting of several source files. First, I wanted to implement some module from the op0en-source \"Libre-SOC\" package, but all modules had a very large number of ports (I / O pins), often exceeding the number of pins available in the FPGA ICE40. This is due to the fact that such modules are used inside more complex modules, e.g. soft-CPU, and are encapsulated with other modules.</p> <p>So my choice fell on a simple project in Verilog (Tx implementation of the UART module), such a project after bitstream generation can be tested on a physical FPGA set with the Lattice ICE40 chip. Besides, this project was once implemented on the \"Elbert v.2\" set with the Xilinx Spartan-3A chip and I have the \"ISE 14.7\" project for it</p> <p>The project consists of several source files: + txstr.v - the main module of the project + uart_tx.v - project sub-module + baudgen_tx.v - project sub-module + baudgen.vh - file with constants included in the project + txstr.pcf - file with pin mapping for FPGA ICE40 (created by me)</p> <p>In the /examples directory, I created a new folder /uart_tx and copied the source files mentioned above into it and went to that directory. Then in the system console I followed the instructions:</p> <p>yosys -p 'synth_ice40 -top txstr -json txstr.json' txstr.v uart_tx.v baudgen_tx.v</p> <p>where txstr is the main module of the project and all verilog source files are listed on the command line</p> <p>The synthesis phase was successful (there were no errors) and a file was created: txstr.json with a list of system connections</p> <p>Then I ran the command in the console:</p> <p>nextpnr-ice40 --hx1k --json txstr.json --pcf txstr.pcf --asc txstr.asc where ice40 --hx1k are trype and FPGA symbol</p> <p>As a result of this command, the txstr.asc file was created with the result of the FPGA implementation phase. This phase was successful.</p> <p>The last command given was:</p> <p>icepack txstr.asc txstr.bin</p> <p>Based on the results of the implementation phase, it created a binary FPGA configuration file named txstr.bin.</p> <p>As you can see, for Lattice's ICE40 FPGAs, you can implement a simple Verilog-based FPGA design using the Symbiflow tools.</p> <p>I also checked the operation of the Verilog language simulator called Verilator - for this purpose I used a bench test from the first example of being able to use an LED diode. The simulator worked correctly. I have used Verilator in the past and I know how to use it to generate a VCD file with simulation timing diagrams, which can then be analyzed with the \"GTKWave\" program.</p>"},{"location":"tpm-spi-dev/","title":"Intro","text":"<p>The goal of this document is to describe the current state of the lpnTPM communication over SPI interface and what are the further plans in this area.</p>"},{"location":"tpm-spi-dev/#replacing-usb-cdc-with-spi-communication-in-ms-tpm-20-ref","title":"Replacing USB CDC with SPI communication in ms-tpm-20-ref","text":"<p>Initially we have enabled the sample code from the <code>ms-tpm-20-ref</code>, which provided the USB CDC communication channel. Our first goal towards the SPI communication was to replace the USB CDC channel with SPI one.</p> <p>We have added basic support for communication with TPM over SPI and dropped CDC support (code available here). Currently, communication protocol does not follow the protocol as defined in the TCG PC Client Specification. This is planned for futher milestones of the project to be fully compatible with existing TPM SPI drivers. For implementation to be compliant with TPM protocol we must use the same header format (current format has only slight differences), and implement full TPM register interface.</p>"},{"location":"tpm-spi-dev/#running","title":"Running","text":"<p>To build and run this application you need latest STM32Cube IDE (at least version 1.10.0). Instructions for building and running has been described here. TPM2 interface is exposed through SPI2. Following pins are used:</p> Pin Function PC2 MISO PC3 MOSI PB10 SCK PB12 CS <p>STM32Cube IDE by default inserts breakpoint at <code>main()</code>, to resume program press F8. After resuming program you should see similar log in <code>SWV ITM Data Console</code> window</p> <pre><code>=========================\n= Nucleo-L476RG TPM 2.0 =\n=========================\n2000.01.01-00:00:00.003GMT: Generated tpmUnique\n    64d35b5495b2960f085a53af30aa2b68\n    1dcde64d11b81f1ba80207cd0546dbc8\n    937003faae4ee104769877877e8a9f8b\n    30a3ce2621641a56c9d3ce1ff95b9eee\n2000.01.01-00:00:00.324GMT: Initialized 16kb NVFile.\n2000.01.01-00:00:00.324GMT: NVFile loaded (16kb, 1970.01.01-00:00:00GMT created, 0 writes, NEVER last)\n2000.01.01-00:00:00.327GMT: TPM_Manufacture(1) requested.\n2000.01.01-00:00:00.654GMT: NVFile written (16kb, 1970.01.01-00:00:00GMT created, 0 writes, NEVER last)\n2000.01.01-00:00:00.654GMT: _plat__SetNvAvail().\n2000.01.01-00:00:00.654GMT: _plat__Signal_PowerOn().\n2000.01.01-00:00:00.654GMT: _plat__Signal_Reset().\n</code></pre> <p></p> <p>As SPI master we use Raspberry PI 3B, TPM is connected to RPI SPI1. To be able to send test commands to TPM <code>spidev</code> driver must be enabled and bound to SPI1. To enable <code>spidev</code>, modify <code>config.txt</code> in RPI boot partition by adding <code>dtoverlay=spi1-1cs</code>. This line has to be added before any section starts, preferably on top of file. RPI must be rebooted for the changes to take effect.</p> <p>Device should be visible as <code>/dev/spidev1.0</code>.</p>"},{"location":"tpm-spi-dev/#testing","title":"Testing","text":"<p>Basic testing can be done using spidev test tool.</p> <p>Commands are sent after 4-byte header. Header first byte determines size of transfer and second byte determines which register to read/write. There are 4 registers:</p> <ul> <li>0x00 - write TPM command into buffer without executing it</li> <li>0x01 - execute TPM command stored in buffer</li> <li>0x02 - read TPM response</li> <li>0x03 - send test response: TPM always responds with   <code>0x42, 0x43, 0xab, 0xcd, 0xde, 0xef</code></li> <li>0x04 - read TPM response size</li> </ul> <p>To do a simple test, first, send special request</p> <pre><code>$ spitest -v -D /dev/spidev1.0 -s 100000 -p '\\x06\\x03\\x00\\x00'\nspi mode: 0x0\nbits per word: 8\nmax speed: 100000 Hz (100 kHz)\nTX | 06 03 00 00 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  |....|\nRX | 00 00 00 00 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  |....|\n</code></pre> <p>TPM should start printing <code>SPI TX error: 3</code> which means it cannot send response due to timeout, this is because host is not waiting for transfer. To receive data, next transfer must be initiated. SPI works in duplex mode simultaneously so some data must be transferred to TPM while receiving response. Here we send NULL bytes.</p> <pre><code>$ spitest -v -D /dev/spidev1.0 -s 100000 -p '\\x00\\x00\\x00\\x00\\x00\\x00'\nspi mode: 0x0\nbits per word: 8\nmax speed: 100000 Hz (100 kHz)\nTX | 00 00 00 00 00 00 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  |......|\nRX | 42 43 AB CD DE EF __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  |BC....|\n</code></pre> <p>Note: number of NULLs must match the number declared in header (here 6 bytes).</p> <p>To send real TPM command (here TPM_Startup) it must be first written into buffer (normally TPM would use FIFO but here we use a simple buffer).</p> <pre><code>$ spitest -v -D /dev/spidev1.0 -s 100000 -p '\\x0c\\x00\\x00\\x00\\x80\\x01\\x00\\x00\\x00\\x0c\\x00\\x00\\x01\\x44\\x00\\x00'\nspi mode: 0x0\nbits per word: 8\nmax speed: 100000 Hz (100 kHz)\nTX | 0C 00 00 00 80 01 00 00 00 0C 00 00 01 44 00 00 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  |.............D..|\nRX | DE DE DE DE DE DE DE DE DE DE DE DE DE DE DE DE __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  |................|\n</code></pre> <p>Note: on RX we receive some junk. This is because test app does not enqueue TX transfer while receiving data and controller re-transfers remnants of previous transfer. This can be (partially) solved by always providing a NULL filled buffer, and using HAL_SPI_TransmitReceive instead of HAL_SPI_Receive. Zephyr (see the section below) already does that which partially solves the problem. However, if TPM does not enqueue transfer right in time, this causes noise on SPI.</p> <p>And now, execute command:</p> <pre><code>$ spitest -v -D /dev/spidev1.0 -s 100000 -p '\\x01\\x01\\x00\\x00\\x01'\n</code></pre> <p>You should see something like this on SWV console</p> <pre><code>TPM command: 80 01 00 00 00 0c 00 00 01 44 00 00\n2000.01.01-00:20:18.201GMT: Executing command TPM_CC_Startup()\n2000.01.01-00:20:18.525GMT: NVFile written (16kb, 1970.01.01-00:00:00GMT created, 0 writes, NEVER last)\n2000.01.01-00:20:18.525GMT: Completion time 0'0\" with ReturnCode {TPM_RC_SUCCESS}\nResponse size: 10\n</code></pre> <p>To read response, type:</p> <pre><code>$ spitest -v -D /dev/spidev1.0 -s 100000 -p '\\x04\\x04\\x00\\x00\\x00\\x00\\x00\\x00'\n$ spitest -v -D /dev/spidev1.0 -s 100000 -p '\\x00\\x00\\x00\\x00'\nspi mode: 0x0\nbits per word: 8\nmax speed: 100000 Hz (100 kHz)\nTX | 00 00 00 00 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  |....|\nRX | 0A 00 00 00 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  |....|\n</code></pre> <p>Response size is 10, so we need to send 4 byte header and then prepare 10 byte transfer</p> <pre><code>$ spitest -v -D /dev/spidev1.0 -s 100000 -p '\\x04\\x02\\x00\\x00\\x00\\x00\\x00\\x00'\n$ spitest -v -D /dev/spidev1.0 -s 100000 -p '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\nspi mode: 0x0\nbits per word: 8\nmax speed: 100000 Hz (100 kHz)\nTX | 00 00 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  |..........|\nRX | 80 01 00 00 00 0A 00 00 00 00 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  |..........|\n</code></pre> <p>Examples above show successful communication attempt, however communication is unstable and it tends to fail frequently. Failure can be simply reproduced by trying commands multiple times.</p> <p>Also, please note that SPI is running at 100 kHz, where TPM specification requires TPM to operate at range 10 MHz - 24 MHz. Currently, upon receiving command TPM is waiting for host to receive response and will not accept further commands until response is received. Before sending command and receiving response there is a delay caused by executing <code>spitest</code> separately. <code>spitest</code> calls may be chained together, but this may result in TPM not responding right in time.</p> <p>STM32 HAL does not provide API to sample SPI chip select, but TPM specification requires some actions to be taken based on the CS value.</p> <p>From TCG PC Client Platform TPM Profile Specification section 6.5.1.1:</p> <ol> <li>For Read Cycles, the TPM SHALL abort a cycle by driving 1 on MISO and    continue to hold MISO at 1 until its CS# signal is deasserted.</li> </ol> <p>Also, TPM needs a way to recover to interrupted transfers. TPM data transfer happens in a few byte chunks (header and data payload of size defined by header). When TPM is deselected, transfer is aborted and TPM should go back into idle state. This may require TPM firmware to sample CS state in order to update its internal state machine.</p> <p>Neither Zephyr provides such an API, except for GPIO chip select, which may not be usable from within SPI slave.</p>"},{"location":"tpm-spi-dev/#summary-of-the-hal-based-approach","title":"Summary of the HAL-based approach","text":"<p>The STM32 HAL approach was continued as it was the easiest path forward for idea verification. Unfortunataly, we faced several obstacles and decided not to continue this path, as this approach is not the target one for multiple reasons:</p> <ul> <li>the STM32L476 is   short on memory when   running the <code>ms-tpm-20-ref</code> stack</li> <li>the STM32L476 will not be able to provide LPC interface, which is common   interface for TPM modules</li> <li>due to the global supply chain issues, the STM32L476 (as most of the others   STM32, and many more MCUs) is infeasible to source</li> </ul> <p>Some more considerations on the hardware replaceement could be found here.</p> <p>One of the paths to move forward is to port the <code>ms-tpm-20-ref</code> stack to some RTOS (such as Zephyr) to gain some more flexibility in tems of hardware switching in the current global situation.</p>"},{"location":"tpm-spi-dev/#prototyping-tpm-spi-communication-with-zephyr","title":"Prototyping TPM SPI communication with Zephyr","text":"<p>Further SPI work has been done on Zephyr, the code is available here. This code tests communication with a dummy TPM implementation as <code>ms-tpm-ref-20</code> has not been fully ported to Zephyr yet.</p> <p>Zephyr has it's own SPI driver, which still uses low level HAL API, however its behaviour is different from high level HAL API we were using previously. First, receiving of multiple bytes at once works fine, which simplifies code - instead of filling RX buffer one byte at a time we can do this in 2 transfers</p> <ul> <li>4 byte TPM header which contains: mode (read or write),   target register address and transfer size</li> <li>data read or write transfer with matching size as defined in TPM header</li> </ul> <p>Note: Current SPI implementation uses different header format than defined by TPM spec. Mode is not present and, on read,  TPM always sends full register, ignoring header size field.</p> Byte Usage 0 Size of transfer 1 Register address 2 Unused (zero) 3 Unused (zero) <p>Currently, there are 3 registers (mininum required to send command and receive response):</p> <ul> <li>TPM_REG_CMD - register used for sending command, there is no  TPM FIFO, entire   command is executed immediatelly after transfer is complete</li> <li>TPM_REG_STATUS - status register, currently contains only response size</li> <li>TPM_REG_RESP - response, there is no FIFO so response must be read during a   single transfer</li> </ul>"},{"location":"tpm-spi-dev/#running-zephyr-sample","title":"Running Zephyr sample","text":"<p>Zephyr sample communicates SPI1 (there were problems in getting SPI2 to work under Zephyr). Following pins are used:</p> Pin Function PA5 SCK PA6 MISO PA7 MOSI <p>Note: Zephyr uses GPIO chip select on SPI1 which works only for master, not slave. So, device is always selected and listening on the bus and there is no need to attach CS. In real world scenario CS is required, in that case SPI controller dedicated CS should be used instead of GPIO.</p> <p></p> <p>To run Zephyr sample, use the following commands:</p> <pre><code>$ docker run -ti \\\n--privileged \\\n-v /dev:/dev \\\n-u $(id -u) \\\n-v $PWD:/workdir \\\n-v $(dirname $SSH_AUTH_SOCK):$(dirname $SSH_AUTH_SOCK) \\\n-e SSH_AUTH_SOCK=$SSH_AUTH_SOCK  \\\nghcr.io/zephyrproject-rtos/zephyr-build:v0.23.3\n(docker)$ west init -m git@github.com:lpn-plant/zephyr-spi-app.git --mr spi zephyr-spi-workspace\n(docker)$ cd zephyr-spi-workspace\n(docker)$ west update\n(docker)$ export ZEPHYR_BASE=$PWD/zephyr\n(docker)$ west build -p auto -b nucleo_l476rg -s zephyr-spi-app/app/\n(docker)$ west flash\n</code></pre> <p>Note: Zephyr outputs to emulated UART over USB which should be visible as /dev/ttyACM*</p>"},{"location":"tpm-spi-dev/#testing-spi-communication","title":"Testing SPI communication","text":"<p>We have provided <code>tpmctl</code> available in zephyr-spi-app repo which can be used to send TPM command and receive response. <code>tpmctl</code> can be built simply by invoking GCC as it does not depend on any external libraries. If cross compiling you can use <code>arm-linux-gnueabihf-gcc</code> or build directly on the target device.</p> <pre><code>$ gcc tpmctl.c -o tpmctl\n</code></pre> <p>Command is sent by piping raw, binary command to <code>tpmctl</code>, output can be either in binary form or hexdump:</p> <pre><code>$ printf '\\x80\\x01\\x00\\x00\\x00\\x0c\\x00\\x00\\x01\\x44\\x00\\x00' | tpmctl -H\n80 01 00 00 00 0a 00 00 00 00\n</code></pre> <p>Note: here we send TPM startup which is the only TPM command supported by SPI test application.</p> <p>Communication works fine with smaller commands (up to 16 bytes), albeit SPI driver keeps complaining that transfer failed even if host got all data.</p> <pre><code>[00:00:08.242,000] &lt;err&gt; spi_ll_stm32: spi_stm32_get_err: err=64\n[00:00:08.242,000] &lt;err&gt; spi: SPI TX failed: -5 (size 10)\n\n[00:00:10.248,000] &lt;err&gt; spi_ll_stm32: spi_stm32_get_err: err=64\n[00:00:10.248,000] &lt;err&gt; spi: SPI TX failed: -5 (size 10)\n\n[00:00:11.386,000] &lt;err&gt; spi_ll_stm32: spi_stm32_get_err: err=64\n[00:00:11.387,000] &lt;err&gt; spi: SPI TX failed: -5 (size 10)\n</code></pre> <p>As per TPM spec, TPM must support transfers up to 64 bytes (excluding 4 byte header). With transfers larger than 8 bytes communication becomes unstable. Transfer from TPM to Host is generally more unstable - Host to TPM transfer (command) can be usually transferred uncorrupted, however responses, usually get corrupted right after 8 byte mark.</p> <pre><code>$ printf '\\x80\\x01\\x00\\x00\\x00\\xfa\\x00\\x00\\x01\\x44\\x00\\x00\\x03\\x29\\xab\\x33\\x64\\xd2\\x41\\xec\\x2d\\x8c\\x31\\x7f\\x3c\\x64\\x68\\x5a\\x7d\\x8e\\xce\\xbe\\xf5\\xfa\\xa0\\xc7\\x06\\xe8\\x07\\x5e\\xb3\\x12\\xfc\\xbc\\x4e\\x61\\x72\\x05\\x3f\\x34\\xf2\\x28\\x44\\xb5\\x40\\x2e\\x21\\x35\\xcc\\x57\\xfa\\xa0\\xc7\\x06' | tpmctl -H\nec 32 48 4e 9d 22 9c db 9d 9d 9d 9d 9d 4e ce ce\nce a7 67 67 67 53 b3 b3 b3 a9 d9 d9 d9 d4 ec ec\nec ea 76 76 76 75 3b 3b 3b 3a 9d 9d 9d 9d 4e ce\nce ce a7 67 67 67 53 b3 b3 b3 a9 d9 d9 d9 d4 ec\n</code></pre> <p>Here command is transferred properly and TPM responds with a hardcoded 64 byte response, but the response becomes corrupted (note repeating patterns). The correct response is</p> <pre><code>ec 32 48 4e 9d 22 9c db 29 9e b4 4a 23 e2 ec e1\n36 4e 1b c2 09 44 eb 65 21 aa db 00 da 60 50 a6\n53 de da 22 5c a5 df 2f 75 b3 9c e0 10 4a 1d a9\n94 e2 0c b8 c1 82 b0 34 d6 ea 10 e1 72 98 88 24\n</code></pre> <p>For SPI to work reliably both host and device must keep transfers in sync, to achieve this on host we execute multiple transfers during a single IOCTL and let the driver handle this. On TPM side, we have to process request quickly and queue response before host initiates next transfer. This adds complexity as the code has to be very well optimized. Currently, there is a workaround that adds delays between transfers to let TPM get ready after executing command, otherwise we won't be able to get response. This workaround should be replaced with better optimized SPI handling on TPM site, as well as implementation of wait states (TPM specific extension to SPI).</p> <p>SPI currently runs at 100 KHz where TPM specification requires support for 10 - 24 MHz range. Currently, communication is completely broken at 1 MHz.</p>"},{"location":"tpm-spi-dev/#further-work","title":"Further work","text":"<p>SPI stability problems must be solved and device must be able to reliably operate at 24 MHz (TPM specification recommends higher frequencies, however these are not mandatory currently).</p> <p>TPM specific SPI extensions must be implemented, such as wait states and bus aborts, which depend on non-standard behaviour not supported directly by SPI drivers/controllers. Implementing this is possible, but complex.</p> <p>Currently, we have implemented only 3 registers, but a real TPM has much more. To be able operate with existing software/hardware we have to implement TPM register interface, along with TPM FIFO interface, interrupt interface and all related registers.</p> <p>Requirements have been also described here</p>"},{"location":"tpm-spi-dump/","title":"SPI communication dump","text":""},{"location":"tpm-spi-dump/#required-hardware","title":"Required hardware","text":"<p>SPI TPMs typically operate at range 10 MHz - 24 MHz as required by TPM specification (larger frequencies are possible). To monitor SPI we are using DSLogic Plus which is capable of operating at up to 400 MHz (but with 3 channels only). As a TPM module we are using ASUS 90MC07D0-M0XBN0 (with Nuvoton NPCT750). Since LPN TPM must run at least at 24 MHz to be compliant with specification we are capturing at 24 MHz, however 90MC07D0-M0XBN0 has been confirmed to work at frequencies as low as 1 MHz.</p> <p>As SPI host we are using Raspberry PI 3B v1.2</p>"},{"location":"tpm-spi-dump/#required-software","title":"Required software","text":"<p>DSView is an open-source software for DSLogic devices. No Linux binaries are provided and unless your distribution already provides a binary package, DSView has to be built manually. Building process is simple and is not covered here.</p>"},{"location":"tpm-spi-dump/#preparing-raspberry-pi","title":"Preparing Raspberry PI","text":"<p>Recent 32-bit RPI OS had a problem with non-working SPI chip select, we recommend using 64-bit version which worked properly. OS can be installed using Raspberry Pi Imager. Please remember to configure user passwords before installing OS to avoid login problems.</p> <p></p> <p>For testing purposes we are going to use Linux driver, which requires changes to device tree. Please save the following contents to temporary file.</p> <pre><code>/dts-v1/;\n/plugin/;\n/ {\ncompatible = \"bcrm,bcm2835\";\n\nfragment@0 {\ntarget = &lt;&amp;spi0&gt;;\ntpm: __overlay__ {\n#address-cells = &lt;0x01&gt;;\n#size-cells = &lt;0x00&gt;;\ntpm@0 {\ncompatible = \"tcg,tpm_tis-spi\";\nreg = &lt;0x00&gt;;\n/* Maximum frequency in Hz */\nspi-max-frequency = &lt;24000000&gt;;\nstatus = \"okay\";\n};\n};\n};\n\nfragment@1 {\ntarget = &lt;&amp;spidev0&gt;;\n__overlay__ {\n/* Disable spidev0 to avoid conflict with TPM */\nstatus = \"disabled\";\n};\n};\n};\n</code></pre> <p>Then within RPI OS boot directory run the following command</p> <pre><code>dtc -I dts -O dtb /tmp/tpm.dts -o overlays/spi0-tpm.dtbo\n</code></pre> <p>Then to actually enable overlay add following lines to <code>config.txt</code> file</p> <pre><code>dtoverlay=spi0-2cs\ndtoverlay=spi0-tpm\n</code></pre> <p>Note: these lines must be added before any section starts, we recommend adding them directly at the top of the file.</p> <p>When booting <code>tpm_tis_spi</code> should be automatically loaded. Added devicetree nodes should be visible at <code>/sys/firmware/devicetree/base/soc/spi@7e204000/tpm@0</code>.</p>"},{"location":"tpm-spi-dump/#attaching-tpm","title":"Attaching TPM","text":"<p>ASUS TPM has a small female header, standard jump wires will not fit unless theirs plastic heads are taken off. To avoid short circuits, cables can be wrapped with electrical tape.</p> <p>This is the pinout of the TPM used</p> <p></p> <p>Following connections must be done</p> TPM Raspberry Pi VCC 3.3V_PWR GND GND MISO_TPM SPI0_MISO MOSI_TPM SPI0_MOSI SCLK#_TPM SPI0_SCLK CS# SPI0_CS0 RST#_TPM GND <p></p> <p>When the TPM is connected to RPI, try running these commands as root</p> <pre><code>rmmod tpm_tis_spi\nmodprobe tpm_tis_spi\n</code></pre> <p>After successful TPM probe, <code>/dev/tpm0</code> and <code>/dev/tpmrm0</code> nodes should appear. If probe failed, then probably TPM is not connected properly (or CS bug mentioned above, try again with CS# connected to GND).</p> <p>Complete setup looks like this:</p> <p></p>"},{"location":"tpm-spi-dump/#monitoring-spi-bus","title":"Monitoring SPI bus","text":"<p>In DSView open Device Options window, set operation mode to buffered (required for DSLogic Plus to operate at 100 MHz with 4 channels). Set voltage threshold to 2.0V and select max 4 channels.</p> <p></p> <p>DSView has built-in decoders for various protocols including TPM over SPI. To enable decoding click on the <code>Decode</code> button from toolbar and search for the <code>SPI TPM</code> protocol. Select proper CLK, MISO, MOSI, CS#, and leave other settings at theirs defaults.</p> <p></p> <p>When configured properly DSView should show TPM registers we read or write, and raw data that goes to/from these registers.</p> <p></p>"},{"location":"tpm-spi-dump/#communication-dumps","title":"Communication dumps","text":"<p><code>data</code> directory in lpn-plant/lpntpm-docs repository contains a few <code>*.dsl</code> files which can be opened in DSView for analysis.</p> <ul> <li>driver_init.dsl -   dump of communication right after loading <code>tpm_tis_spi</code> driver.</li> <li>tpm2_startup-c.dsl -   result of running <code>tpm2_startup -c</code> command.</li> <li>tpm2_pcrread.dsl -   result of running <code>tpm2_pcrread</code> command. At this point PCRs were at theirs   default values.</li> </ul>"},{"location":"tpm_lpc_spi_interface/","title":"TPM LPC/SPI interface","text":"<p>LPC and SPI has been described in PC Client Platform TPM profile.</p>"},{"location":"tpm_lpc_spi_interface/#lpc","title":"LPC","text":"<p>LPC has been described in section 7.3.</p> <ul> <li>TPM interrupts</li> <li>TPM uses LPC SIRQ (also known as SERIRQ) for signaling interrupts.</li> <li>Unfortunatelly, serialized interrupts are not described in Intel LPC     specification.     LPC WikiPedia article has     some information available and     Serialized IRQ for PCI.</li> <li>The IRQ which TPM may trigger is configured by Host by writing     to <code>TPM_INT_VECTOR_x</code> register (see Table 38).</li> <li>TPM uses specific read/write cycles for communication with Host</li> <li>LPC protocol defines 2 fields (START and CYCTYPE, both 4-bit long) which     determine LPC cycle type. TPM uses its own cycle type where START=0101     always. CYCTYPE=0010 for TPM write cycle and CYCTYPE=0000 for TPM read     cycle.</li> <li>TPM must verify cycle type and ignore non-TPM cycles.</li> <li>LPC data transfer</li> <li>Table 43 and 44 show LPC frame format    </li> <li>ADDR field contains 16-bit TPM register address. See Table 9 for details how     TPM MMIO space maps to register address emitted on the bus.     </li> <li>It should be noted that LPC can transfer only a single data byte (DATA low     and high fields). Please note that the lowest nibble (4 bits) are transfered     first and then the highest 4 bits.</li> <li>LPC has native flow control, see   Intel LPC specification   section <code>4.2.1.8</code> for details.</li> </ul>"},{"location":"tpm_lpc_spi_interface/#spi","title":"SPI","text":"<p>SPI has been described in-depth in section 7.4.</p> <ul> <li>TPM interrupts</li> <li>TPM must implement PIRQ# pin. See section 7.4.3.</li> <li>PIRQ# is active-low, TPM connects PIRQ# to ground to trigger interrupt.</li> <li>TPM must not implement an internal PIRQ# pull-up.</li> <li>Prior to triggering interrupts TPM must set interrupt status registers     accordingly.</li> <li>TPM must not assert another interrupt until it receives TPM_EOI.</li> <li>Flow control</li> <li>Contrary to LPC, SPI does not have native flow control. TPM flow control on     SPI is a non-standard behaviour, not defined by SPI specification.</li> <li>TPM may insert wait state to delay data transfer (from Host to TPM).</li> <li> <p>TPM must insert wait state when it's internal FIFO is full or accept the     transaction.</p> <p>The TPM, if it doesn\u2019t insert a wait state at the designated point must accept the transaction, if the transaction doesn\u2019t cross a register boundary. If the transaction crosses a register boundary, the TPM may choose to accept all the data and discard the data that exceeds the size limit for that register as long as doing so does not cause a change to the state of any adjacent register.</p> </li> <li> <p>Usually TPM is allowed to insert as many wait states (each wait state is 8     clock cycles) as it wants, except during read of a few registers where it is     allowed to insert only one wait cycle. TPM cannot insert more than 1 wait     cycle for the following registers: TPM_ACCESS_x, TPM_STS_x,     TPM_INTF_CAPABILITY, TPM_INT_ENABLE, TPM_INT_STATUS, TPM_INT_VECTOR,     TPM_DID, TPM_VID.</p> </li> <li> <p>TPM must insert wait state if Host attempts to write data while TPM is     busy - Host should check TPM status register to see if TPM is ready.</p> <p>For writes, the TPM is required to insert wait states if software attempts to write data without waiting for the TPM to transition to the Ready state.</p> </li> <li> <p>Data transmission (see section 7.4.6 for details)</p> </li> <li>TPM uses SPI mode 0 (CPHA=0, CPOL=0), no other modes are supported.</li> <li>SPI packet is outlined in Table 48</li> <li>Data transfer starts from the least significant byte and ends on the     most significant byte.   </li> <li>The first bit transferred determines whether transaction is read or write.</li> <li>This is followed by a single reserved bit.</li> <li>This is followed by 6 bit length from 1 byte to 64 bytes. This is length of     the data payload, excluding 32-bit header.</li> <li>Length is followed by 24-bit register address, the highest byte is always     0xD4. See Table 9 for details how TPM MMIO space maps to register address     emitted on the bus.     </li> </ul>"},{"location":"tpm_lpc_spi_interface/#tpm-register-interface","title":"TPM register interface","text":"<p>According to section 6.3.1 Host may attempt to read less bytes than there actually is in register, TPM must handle this, it must also handle read from the middle of register, e.g. if we have a 32-bit register at 0x20, 1 byte read from 0x20 must yield the first byte of that register, read from 0x21 must yield the second byte from that register.</p> <p>Software must never attempt to cross register size in a same transfer. In case of LPC this won't be noticed by TPM as all multi-byte LPC transfers are split into multiple transfers, e.g. if hosts writes 0x11223344 to register 0x10 on LPC it will appear as - 0x44 write to 0x10 - 0x33 write to 0x11 - 0x22 write to 0x12 - 0x11 write to 0x13</p> <p>Even if register boundary were crossed this doesn't make any difference for TPM. In case of SPI data payload of a single transfer cannot be bigger than size of register and cannot cross register boundary. Still, this must be handled, TPM specification does not define clearly what the behaviour should be.</p> <p>For SPI, if a TPM receives an access request with a length that exceeds the size of the register specified in the transaction address: (...) b. Writes: The TPM SHALL update the register designated by the start address. The TPM MAY update additional, adjacent registers within the targeted address range. The TPM SHALL NOT change the state of adjacent registers if the writes to that register are dropped.</p> <p>The TPM SHOULD NOT abort (as defined in Section 6.5.1.1 Bus Aborts) an entire transaction that crosses a register boundary.</p> <p>We choosed to write as many registers as possible, if register write is dropped (such as when register is not present or read-only) bus abort is raised (see section 6.5.1.1). This stops write on the register which triggered error and further registers are not updated.</p> <p>TPM must implement the following registers (non-exauhstive list): - TPM_DID_VID_x - contains Vendor and Device ID of the TPM, see Table 13 for   details. - TPM_RID_x - contains revision ID, see Table 14 for details. - TPM_INTERFACE_ID_x - mandatory register, see Table 15. - interrupt control/status registers - other registers are required, Table 19 for FIFO interface requirements.</p>"},{"location":"tpm_lpc_spi_interface/#tpm-commands","title":"TPM commands","text":"<p>There are two interfaces for sending TPM commands and reading back responses, one is CRB not covered here and another FIFO. See section 6.5.2 for details about FIFO mode.</p> <p>In FIFO mode command is written to <code>TPM_DATA_FIFO_x</code> register. Host writes entire command packet to FIFO and triggers command execution by setting <code>tpmGo</code> in the <code>TPM_STS</code> (see Table 21) register which triggers command execution. When response is available TPM signals it by setting <code>dataAvail</code> bit in status register. Host can now read response from <code>TPM_DATA_FIFO_x</code>.</p> <p>There is also <code>TPM_XDATA_FIFO_x</code> register which allows for writes that span multiple bytes, this is especially useful for SPI as it can send more than one dword in a single packet. See section 6.3.1 for details.</p> <p>Unlike LPC, the SPI bus does not limit transfers to a single byte. The extended size data register (TPM_XDATA_FIFO_x) and CRB data buffer allow a single write to offset 0x0080h up to the maximum transfer size reported by TPM_INTF_Capability_x.DataTransferSizeSupport, without requiring Software to increment the address.</p> <p>TPM is required to accept at least 1 byte transfers through <code>TPM_XDATA_FIFO_x</code></p> <p>The TPM SHALL accept transactions to offset 0x0080h that are of any length from 1 byte to the maximum supported length (as reported in the Interface Capability register, Section 6.5.2.7 Interface Capability).</p> <p>According to Table 12 <code>TPM_XDATA_FIFO_x</code> spans only a 4 byte region (followed by reserved region), this raises doubts how big transfer should be handled as usually address is increased after each byte. Until this is clarified TPM should not report sizes bigger that 4 bytes in <code>TPM_INTF_Capability_x.DataTransferSizeSupport</code>.</p>"},{"location":"tpm_modules_pinout/","title":"TPM modules pinout","text":"<p>This document describes a few different variants of the TPM module pinouts which are available on some of the PC mainboards. This research was made to design a few variants of the TPM modules with the most popular pinouts. In this chapter below, the same pinouts of TPM modules were grouped. The analyzed mainbaords are chosen based on what we have available for testing, but also based on the best sellers positions from the Newegg.com for some of the most recent mainboards.</p>"},{"location":"tpm_modules_pinout/#lpc-interface","title":"LPC interface","text":"<p>LPC was (and still is) the most common interface for the TPM.</p>"},{"location":"tpm_modules_pinout/#asrock-rack-x470-d4u-romed8-2t-server-mb-epc621d8a-h170m-pro4","title":"AsRock Rack X470 D4U, ROMED8-2T Server MB, EPC621D8A, H170M PRO4","text":"<p>Below there are two different pinouts that could be treated as interchangeable. PCICLK is a 33MHz standard clock (same with CK_33M_TPM). F_CLKRUN# is a signal when asserted instructs chipset to supply a clock signal. On the pinout below it is tied to GND which means always asserted (clock is always running).</p> <p> </p> <ul> <li>Manuals:</li> <li>User Manual X470</li> <li>User Manual ROMED8-2T</li> <li>User Manual EPC621D8A</li> <li>User Manual H170M</li> </ul>"},{"location":"tpm_modules_pinout/#asus-m5a99fx-pro-r20-maximus-vii-hero-z87-plus-maximus-vii-ranger","title":"Asus M5A99FX Pro r2.0, MAXIMUS VII HERO, Z87 PLUS, MAXIMUS VII RANGER","text":"<ul> <li>Manuals:</li> <li>User Manual M5A99FX</li> <li>User Manual MAXIMUS VII HERO</li> <li>User Manual Z87 PLUS</li> <li>User Manual MAXIMUS VII RANGER</li> </ul>"},{"location":"tpm_modules_pinout/#asus-maximus-ix-formula-crosshair-viii-dark-hero-rog-strix-b450-f-gaming","title":"Asus MAXIMUS IX FORMULA, CROSSHAIR VIII DARK HERO, ROG STRIX B450-F Gaming","text":"<ul> <li>Manuals:</li> <li>User Manual MAXIMUS IX FORMULA</li> <li>User Manual ROG CROSSHAIR</li> <li>User Manual B450-F</li> </ul>"},{"location":"tpm_modules_pinout/#asus-tpm-m-r20-z97-pro-gamer","title":"Asus TPM-M R2.0, Z97 PRO GAMER","text":"<ul> <li>Manuals:</li> <li>User Manual TPM-M</li> <li>User Manual Z97 PRO GAMER</li> </ul>"},{"location":"tpm_modules_pinout/#gigabyte-ga-a320m-s2h-amd-a320-ga-b250-hd3p-b450-aorus-pro-ga-z77-d3h-ga-970a-ud3p","title":"Gigabyte GA A320M-S2H AMD A320, GA B250 HD3P, B450 Aorus Pro, GA Z77 D3H, GA 970A-UD3P","text":"<p>Below there are two different pinouts that could be treated as interchangeable. SUSCLK is a RTC clock signal which is not used for TPM so it could be ignored.</p> <p> </p> <ul> <li>Manuals:</li> <li>User Manual Z77X D3H</li> <li>User Manual Z77 D3H</li> <li>User Manual 970A-UD3P</li> <li>User Manual A320M-S2H</li> <li>User Manual B250 HD3P</li> <li>User Manual B450 AORUS PRO</li> </ul>"},{"location":"tpm_modules_pinout/#msi-b75ma-e33-msi-b85m-e45-msi-b350-tomahawk-msi-x99a-gaming-9-ack","title":"MSI B75MA E33, MSI B85M E45, MSI B350 TOMAHAWK, MSI X99A GAMING 9 ACK","text":"<ul> <li>Manuals:</li> <li>User Manual B75MA E33</li> <li>User Manual B85M E45</li> <li>User Manual TOMAHAWK</li> <li>User Manual X99A</li> </ul>"},{"location":"tpm_modules_pinout/#supermicro-x10dal-i-supermicro-mbd-m12swa","title":"Supermicro X10DAL-i, Supermicro MBD M12SWA","text":"<p>Below there are two different pinouts that could be treated as interchangeable.</p> <p> </p> <ul> <li>Manuals:</li> <li>User Manual Supermicro MBD M12SWA</li> <li>User Manual X10DAL-i</li> </ul>"},{"location":"tpm_modules_pinout/#spi-interface","title":"SPI interface","text":"<p>SPI interface becomes more and more common for TPM modules, especially for the more recent mainboards. We can expect that this interface will be more commonly used in the modern mainbards, as the LPC interface becomes slowly deprecated for modern processors.</p>"},{"location":"tpm_modules_pinout/#asus-b550-plus-tuf-gaming-asus-rog-strix-x570-f-gaming","title":"Asus-B550 PLUS TUF GAMING, Asus-ROG STRIX X570-F GAMING","text":"<p>Below there are two different pinouts that could be treated as interchangeable.</p> <p> </p> <ul> <li>Manuals:</li> <li>User Manual STRIX X570-F</li> <li>User Manual B550 PLUS</li> </ul>"},{"location":"tpm_modules_pinout/#msi-z590-pro-wifi","title":"MSI Z590 PRO WiFi","text":"<ul> <li>Manuals:</li> <li>User Manual Z590</li> </ul>"},{"location":"tpm_modules_pinout/#gigabyte-z590-aorus-master","title":"Gigabyte Z590 AORUS MASTER","text":"<ul> <li>Manuals:</li> <li>User Manual</li> </ul>"},{"location":"tpm_modules_pinout/#summary","title":"Summary","text":"<p>There is a relation between TPM modules pinouts at the same vendors. For typical motherboards from one and similar series, pinouts are the same. On the other hand, the same manufacturer also supports different pinouts in the case of different models of motherboards. So it couldn't be said that always the same vendor supports the same pinout.</p> <p>During our research, we have identified:</p> <ul> <li>6 unique LPC TPM pinouts:</li> <li>AsRock (18-pin)</li> <li>Asus (20-pin)</li> <li>Asus (14-pin)</li> <li>Gigabyte (20-pin)</li> <li>MSI (14-pin)</li> <li>Supermicro (20-pin)</li> <li>3 unique SPI TPM pinouts:</li> <li>Asus (14-pin)</li> <li>MSI (12-pin)</li> <li>Gigabyte (12-pin)</li> </ul> <p>These pinouts will be used to define hardware requirements for the TPM boards and, later on, to deisgn TPM adapter boards.</p>"},{"location":"tpm_renders/","title":"TPM modules renders","text":""},{"location":"tpm_renders/#the-tpm-concept","title":"The TPM concept","text":"<p>According to the many varied pinouts necessary was design the concept of TPM module which can fit the motherboard pinout. There was the consideration of two kinds of the interface (SPI and LPC). The whole setup would be made of two PCBs. One is the main PCB with the MCU and SPI or LPC configured socket and the second is the adapter that fits the motherboards pinouts. </p>"},{"location":"tpm_renders/#concept-of-slim-adapter","title":"Concept of slim adapter","text":"<p>Because of limited space on the motherboard, we decided to design the slim variant of the TPM module. Dimensions are shown in the attached graphics below.</p>"},{"location":"tpm_renders/#the-main-module","title":"The main module","text":""},{"location":"tpm_renders/#the-adapter","title":"The adapter","text":""},{"location":"tpm_renders/#the-assembly","title":"The assembly","text":""},{"location":"tpm_renders/#an-example-of-usage-with-motherboard","title":"An example of usage with motherboard","text":"<p> Thanks for that design the widest element (connector that connects the whole design with motherboard socket) measures 5mm. That allowed to get slim contour. The length of the design is indicative and might be changed.</p>"}]}